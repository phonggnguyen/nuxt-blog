{
    "version": "https://jsonfeed.org/version/1",
    "title": "Open Source Developer | AnyBlog",
    "home_page_url": "nuxt-blog-azure.vercel.app",
    "feed_url": "nuxt-blog-azure.vercel.app/feed.json",
    "icon": "nuxt-blog-azure.vercel.app/cover.png",
    "items": [
        {
            "id": "nuxt-blog-azure.vercel.app/blog/how-the-heck-does-vite-work-2",
            "content_html": "<div><div><div><div><svg><path><animate></animate></path><rect><animate></animate></rect></svg></div><div><!--[-->Note: This article was written for the alpha of Vite. I'd recommend reading Patak's great article on <a><!--[-->The Vite Ecosystem<!--]--></a>.<!--]--></div></div></div><p><!--[-->In rebuilding my old Nuxt.js personal site, I wanted to challenge myself to learn the latest tech, the unknown.<!--]--></p><p><!--[-->The unknown was the new project by Evan You: <a><!--[-->‚ö° Vite<!--]--></a> (/veet/). Called Fast, for the üá´üá∑ Frenchies.<!--]--></p><p><!--[-->I'll be comparing how Vite works to the standard <a><!--[-->webpack<!--]--></a> config using <a><!--[-->webpack-dev-server<!--]--></a>, which all major Vue frameworks\nare using.<!--]--></p><p><!--[-->We'll be looking at how Vite no-bundling works, by first looking at how webpack's bundling works and what the difference is. Afterwards I'll give you some\nrecommendations for setting up Vite for yourself.<!--]--></p><p><!--[-->Vite could the next best thing in tooling, currently, it's still in a pre-release stage though so be careful out there üêõ.<!--]--></p><h2><a><!--[-->A Recap on Vite<!--]--></a></h2><p><!--[-->Vite is a web development build tool which supports Vue, React and Preact. It's an experimental new direction in how build tools can work with a greenfield ecosystem.<!--]--></p><p><!--[-->Vite's core functionality is similar to webpack + webpack-dev-server with some core improvements\non developer experience:<!--]--></p><ul><!--[--><li><!--[-->‚åõ Less time waiting for your app to start, regardless of app size<!--]--></li><li><!--[-->üî• Hot module reloading (HMR) that is basically instant, regardless of app size<!--]--></li><li><!--[-->üî® On-demand compilation<!--]--></li><li><!--[-->üôÖ‚Äç‚ôÇÔ∏è Zero configuration for numerous pre-processors out of the box<!--]--></li><li><!--[-->üìú Esbuild powered typescript / jsx (super quick)<!--]--></li><!--]--></ul><h3><a><!--[-->Speed Example<!--]--></a></h3><p><!--[-->To give you a quick idea on how much faster it is, the below comparison is for Vue CLI which uses webpack. The bigger your app\nis the more noticeable the speed difference will be.<!--]--></p><figure><table><!--[--><thead><!--[--><tr><!--[--><th><!--[--><!--]--></th><th><!--[-->Build Time<!--]--></th><th><!--[-->Dev Server Start Time<!--]--></th><th><!--[-->Dev Page Load Time<!--]--></th><!--]--></tr><!--]--></thead><tbody><!--[--><tr><!--[--><td><!--[-->Vue CLI<!--]--></td><td><!--[--><span>5.14s</span><!--]--></td><td><!--[--><span>2568ms</span><!--]--></td><td><!--[--><span>320ms</span><!--]--></td><!--]--></tr><tr><!--[--><td><!--[-->Vite<!--]--></td><td><!--[--><span>2.39s</span><!--]--></td><td><!--[--><span>232ms</span>Ô∏è<!--]--></td><td><!--[--><span>379ms</span><!--]--></td><!--]--></tr><!--]--></tbody><!--]--></table><figcaption>New Vue 3 project / 10 components / no Babel / 2nd run, in development.</figcaption></figure><h2><a><!--[-->Vite vs webpack<!--]--></a></h2><p><!--[-->The main functional difference you'll notice with Vite and your webpack app, is how code is served in development and which modules are supported.<!--]--></p><p><!--[-->Don't worry if the below terms don't make sense to you, we'll be exploring them below.<!--]--></p><h3><a><!--[-->webpack (Nuxt.js / Vue CLI / etc)<!--]--></a></h3><ul><!--[--><li><!--[-->Supported Modules: <a><!--[-->ES Modules<!--]--></a>, <a><!--[-->CommonJS<!--]--></a> and <a><!--[-->AMD Modules<!--]--></a><!--]--></li><li><!--[-->Dev Server: Bundled modules served via webpack-dev-server using <a><!--[-->Express.js<!--]--></a> web server<!--]--></li><li><!--[-->Production Build: webpack<!--]--></li><!--]--></ul><h3><a><!--[-->Vite<!--]--></a></h3><ul><!--[--><li><!--[-->Supported Modules: <a><!--[-->ES Modules<!--]--></a><!--]--></li><li><!--[-->Dev Server: Native-ES-Modules, served via Vite using a <a><!--[-->Koa<!--]--></a> web server<!--]--></li><li><!--[-->Production build: <a><!--[-->Rollup<!--]--></a><!--]--></li><!--]--></ul><div><div><div><svg><path><animate></animate></path><rect><animate></animate></rect></svg></div><div><!--[-->Check out Mozilla's <a><!--[-->article<!--]--></a> on ES Modules if they're new to you.<!--]--></div></div></div><h2><a><!--[-->Understanding webpack<!--]--></a></h2><p><!--[-->To understand how Vite works, it's best to look at how webpack works first. Even with its popularly, understanding webpack can be intimidating, so I'll try to keep it simple.<!--]--></p><p><!--[-->webpack is versatile in what you can do with it, but at its core, it will:<!--]--></p><ul><!--[--><li><!--[-->Starting with an entry file, build a tree of your dependencies: all the imports, exports, requires from your code/files<!--]--></li><li><!--[-->Transform / compile modules: think transpiling js for older browsers, turning SCSS into CSS<!--]--></li><li><!--[-->Use algorithms to sort, rewrite and concatenate code<!--]--></li><li><!--[-->Optimise<!--]--></li><!--]--></ul><h3><a><!--[-->webpack In Development<!--]--></a></h3><p><!--[-->Assuming you're using one of the main Vue frameworks, when you start your app in development, it is going to do a few things:<!--]--></p><ol><!--[--><li><!--[-->Bundle all of your code<!--]--></li><li><!--[-->Start the webpack-dev-server, the Express.js web server which will serve the bundled code<!--]--></li><li><!--[-->Setup sockets which will handle the Hot Module Reloading<!--]--></li><!--]--></ol><p><!--[-->As you may notice with your own apps, the bigger they grow, the longer you have to wait to start coding.<!--]--></p><figure><img><figcaption>The Nuxt logo is almost burnt into my monitor at this point.</figcaption></figure><p><!--[-->Bundling in development is quicker because you don't need to do as much with the code, however,\nas your app grows, it will become painfully slow, especially on older machines.<!--]--></p><h3><a><!--[-->webpack Component Example<!--]--></a></h3><p><!--[-->I created a default Vue 3 <a><!--[-->Vue CLI<!--]--></a> project, which has an entry <code><!--[-->App.vue<!--]--></code> file using the <code><!--[-->HelloWorld.vue<!--]--></code> component.\nLet's see how this component gets to my browser.<!--]--></p><p><!--[-->HelloWorld.vue component:<!--]--></p><div><!--[--><span>HelloWorld.vue</span><!--[--><pre><code><span><span>&lt;</span><span>script</span><span>&gt;</span></span><span><span>export</span><span> </span><span>default</span><span> {</span></span><span><span>  props</span><span>:</span><span> {</span></span><span><span>    msg</span><span>:</span><span> </span><span>String</span></span><span><span>  }</span></span><span><span>}</span></span><span><span>&lt;/</span><span>script</span><span>&gt;</span></span><span></span><span><span>&lt;</span><span>template</span><span>&gt;</span></span><span><span>  &lt;</span><span>div</span><span> </span><span>class</span><span>=</span><span>\"</span><span>hello</span><span>\"</span><span>&gt;</span></span><span><span>    &lt;</span><span>h</span><span>1&gt;{{ </span><span>msg</span><span> }}&lt;/</span><span>h</span><span>1&gt;</span></span><span><span>  &lt;/</span><span>div</span><span>&gt;</span></span><span><span>&lt;/</span><span>template</span><span>&gt;</span></span><span></span><span><span>&lt;</span><span>style</span><span> </span><span>scoped</span><span>&gt;</span></span><span><span>h1</span><span> {</span></span><span><span>  </span><span>color</span><span>:</span><span> </span><span>green</span><span>;</span></span><span><span>}</span></span><span><span>&lt;/</span><span>style</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><p><!--[-->When I start my app and visit localhost I get the following HTML from the Express.js server.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>&lt;!</span><span>DOCTYPE</span><span> </span><span>html</span><span>&gt;</span></span><span><span>&lt;</span><span>html</span><span> </span><span>lang</span><span>=</span><span>\"</span><span>en</span><span>\"</span><span>&gt;</span></span><span><span>  &lt;</span><span>head</span><span>&gt;</span></span><span><span>    &lt;</span><span>meta</span><span> </span><span>charset</span><span>=</span><span>\"</span><span>utf-8</span><span>\"</span><span>&gt;</span></span><span><span>    &lt;</span><span>meta</span><span> </span><span>http-equiv</span><span>=</span><span>\"</span><span>X-UA-Compatible</span><span>\"</span><span> </span><span>content</span><span>=</span><span>\"</span><span>IE=edge</span><span>\"</span><span>&gt;</span></span><span><span>    &lt;</span><span>meta</span><span> </span><span>name</span><span>=</span><span>\"</span><span>viewport</span><span>\"</span><span> </span><span>content</span><span>=</span><span>\"</span><span>width=device-width,initial-scale=1.0</span><span>\"</span><span>&gt;</span></span><span><span>  &lt;/</span><span>head</span><span>&gt;</span></span><span><span>  &lt;</span><span>body</span><span>&gt;</span></span><span><span>    &lt;</span><span>div</span><span> </span><span>id</span><span>=</span><span>\"</span><span>app</span><span>\"</span><span>&gt;&lt;/</span><span>div</span><span>&gt;</span></span><span><span>    &lt;</span><span>script</span><span> </span><span>type</span><span>=</span><span>\"</span><span>text/javascript</span><span>\"</span><span> </span><span>src</span><span>=</span><span>\"</span><span>/js/chunk-vendors.js</span><span>\"</span><span>&gt;&lt;/</span><span>script</span><span>&gt;</span></span><span><span>    &lt;</span><span>script</span><span> </span><span>type</span><span>=</span><span>\"</span><span>text/javascript</span><span>\"</span><span> </span><span>src</span><span>=</span><span>\"</span><span>/js/app.js</span><span>\"</span><span>&gt;&lt;/</span><span>script</span><span>&gt;</span></span><span><span>  &lt;/</span><span>body</span><span>&gt;</span></span><span><span>&lt;/</span><span>html</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><p><!--[-->You'll notice we have 2 script files there: <code><!--[-->chunk-vendor.js<!--]--></code> and <code><!--[-->app.js<!--]--></code>. On inspecting them you'd see a lot of gibberish looking code.\nit helps to use the <a><!--[-->webpack-bundle-analyzer<!--]--></a> to see how it works visually.<!--]--></p><h4><a><!--[-->chunk-vendors.js<!--]--></a></h4><p><!--[-->These are third-party modules, usually coming from <code><!--[-->node_modules<!--]--></code>. The two main libraries in here are Vue itself and sockjs which is used for HMR.<!--]--></p><figure><img><figcaption>The two top libraries are Vue.js and Sock.js (For HMR)</figcaption></figure><h4><a><!--[-->app.js<!--]--></a></h4><p><!--[-->This is all the code for my application. It contains components, assets, etc. You'll notice that for an SFC it splits\nit into multiple modules.<!--]--></p><figure><img><figcaption>My app is two components, App.vue and HelloWorld.vue</figcaption></figure><p><!--[-->Taking a quick look at the <code><!--[-->app.js<!--]--></code> file, we can find some of the <code><!--[-->HelloWorld<!--]--></code> component code. As you can see in the above image,\nall parts of the SFC are separate modules: the wrapper, CSS, template, js.<!--]--></p><p><!--[-->The wrapper module is defining and importing the other models, some beautiful code.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>/***/</span><span> </span><span>\"</span><span>./src/components/HelloWorld.vue</span><span>\"</span><span>:</span></span><span><span>/*!***************************************!*\\</span></span><span><span>  !*** ./src/components/HelloWorld.vue ***!</span></span><span><span>  \\***************************************/</span></span><span><span>/*! exports provided: default */</span></span><span><span>/***/</span><span> (</span><span>function</span><span>(</span><span>module</span><span>, </span><span>__webpack_exports__</span><span>, </span><span>__webpack_require__</span><span>) {</span></span><span></span><span><span>\"</span><span>use strict</span><span>\"</span><span>;</span></span><span><span>eval</span><span>(</span><span>\"</span><span>__webpack_require__.r(__webpack_exports__);</span><span>\\n</span><span>/* harmony import */ var _HelloWorld_vue_vue_type_template_id_469af010_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HelloWorld.vue?vue&amp;type=template&amp;id=469af010&amp;scoped=true */ </span><span>\\\"</span><span>./src/components/HelloWorld.vue?vue&amp;type=template&amp;id=469af010&amp;scoped=true</span><span>\\\"</span><span>);</span><span>\\n</span><span>/* harmony import */ var _HelloWorld_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HelloWorld.vue?vue&amp;type=script&amp;lang=js */ </span><span>\\\"</span><span>./src/components/HelloWorld.vue?vue&amp;type=script&amp;lang=js</span><span>\\\"</span><span>);</span><span>\\n</span><span>/* empty/unused harmony star reexport *//* harmony import */ var _HelloWorld_vue_vue_type_style_index_0_id_469af010_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HelloWorld.vue?vue&amp;type=style&amp;index=0&amp;id=469af010&amp;scoped=true&amp;lang=css */ </span><span>\\\"</span><span>./src/components/HelloWorld.vue?vue&amp;type=style&amp;index=0&amp;id=469af010&amp;scoped=true&amp;lang=css</span><span>\\\"</span><span>);</span><span>\\n\\n\\n\\n\\n\\n</span><span>_HelloWorld_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__[</span><span>\\\"</span><span>default</span><span>\\\"</span><span>].render = _HelloWorld_vue_vue_type_template_id_469af010_scoped_true__WEBPACK_IMPORTED_MODULE_0__[</span><span>\\\"</span><span>render</span><span>\\\"</span><span>]</span><span>\\n</span><span>_HelloWorld_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__[</span><span>\\\"</span><span>default</span><span>\\\"</span><span>].__scopeId = </span><span>\\\"</span><span>data-v-469af010</span><span>\\\"\\n</span><span>/* hot reload */</span><span>\\n</span><span>if (true) {</span><span>\\n</span><span>  _HelloWorld_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__[</span><span>\\\"</span><span>default</span><span>\\\"</span><span>].__hmrId = </span><span>\\\"</span><span>469af010</span><span>\\\"\\n</span><span>  const api = __VUE_HMR_RUNTIME__</span><span>\\n</span><span>  module.hot.accept()</span><span>\\n</span><span>  if (!api.createRecord('469af010', _HelloWorld_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__[</span><span>\\\"</span><span>default</span><span>\\\"</span><span>])) {</span><span>\\n</span><span>    api.reload('469af010', _HelloWorld_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__[</span><span>\\\"</span><span>default</span><span>\\\"</span><span>])</span><span>\\n</span><span>  }</span><span>\\n</span><span>  </span><span>\\n</span><span>  module.hot.accept(/*! ./HelloWorld.vue?vue&amp;type=template&amp;id=469af010&amp;scoped=true */ </span><span>\\\"</span><span>./src/components/HelloWorld.vue?vue&amp;type=template&amp;id=469af010&amp;scoped=true</span><span>\\\"</span><span>, function(__WEBPACK_OUTDATED_DEPENDENCIES__) { /* harmony import */ _HelloWorld_vue_vue_type_template_id_469af010_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HelloWorld.vue?vue&amp;type=template&amp;id=469af010&amp;scoped=true */ </span><span>\\\"</span><span>./src/components/HelloWorld.vue?vue&amp;type=template&amp;id=469af010&amp;scoped=true</span><span>\\\"</span><span>);</span><span>\\n</span><span>(() =&gt; {</span><span>\\n</span><span>    api.rerender('469af010', _HelloWorld_vue_vue_type_template_id_469af010_scoped_true__WEBPACK_IMPORTED_MODULE_0__[</span><span>\\\"</span><span>render</span><span>\\\"</span><span>])</span><span>\\n</span><span>  })(__WEBPACK_OUTDATED_DEPENDENCIES__); }.bind(this))</span><span>\\n\\n</span><span>}</span><span>\\n\\n</span><span>_HelloWorld_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__[</span><span>\\\"</span><span>default</span><span>\\\"</span><span>].__file = </span><span>\\\"</span><span>src/components/HelloWorld.vue</span><span>\\\"\\n\\n</span><span>/* harmony default export */ __webpack_exports__[</span><span>\\\"</span><span>default</span><span>\\\"</span><span>] = (_HelloWorld_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__[</span><span>\\\"</span><span>default</span><span>\\\"</span><span>]);</span><span>\"</span><span>);</span></span></code></pre><!--]--><!--]--></div><p><!--[-->The main takeaway here is that within the <code><!--[-->app.js<!--]--></code> file contains all modules for my app.<!--]--></p><p><!--[-->webpack does let you chunk the bundles how you like, for Nuxt.js it chunks routes individually. The more chunks though,\nthe more requests and more potential blocking js.<!--]--></p><p><!--[-->You may see the problem here, we have multiple monolith files that need to be generated anytime we want to use our app.\nWhen we change a file for HMR, we need to regenerate the entire file.<!--]--></p><h2><a><!--[-->Understanding Vite<!--]--></a></h2><p><!--[-->Vite doesn't set out to be a new bundler. Rather, it's a pre-configured build environment using the Rollup\nbundler and a tool for local development.<!--]--></p><h3><a><!--[-->Vite In Development<!--]--></a></h3><p><!--[-->Vite makes the assumption that developers are going to be using the latest browser versions, so it can safely rely on the\nlatest JS functionality straight from the browser - in other words, no babel transpiling!<!--]--></p><p><!--[-->When you start Vite for the first time pre-optimisations will be done on your <code><!--[-->node_modules<!--]--></code>, then <a><!--[-->Koa<!--]--></a>,\na light-weight node web server starts to serve your app.<!--]--></p><p><!--[-->There is no bundling or compiling needed to start the dev server, so it's damn quick (&lt; 300ms).<!--]--></p><p><!--[-->When you open your Vite app you'll be served the <code><!--[-->index.html<!--]--></code> from the server. The browser is going to read the <code><!--[-->index.html<!--]--></code>\nand know how to parse the Native-ES-Module code.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>&lt;</span><span>script</span><span> </span><span>type</span><span>=</span><span>\"</span><span>module</span><span>\"</span><span>&gt;</span><span>import</span><span> </span><span>\"</span><span>/vite/client</span><span>\"</span><span>&lt;/script&gt;</span></span><span><span>&lt;</span><span>div</span><span> </span><span>id</span><span>=</span><span>\"</span><span>app</span><span>\"</span><span>&gt;&lt;/</span><span>div</span><span>&gt;</span></span><span><span>&lt;</span><span>script</span><span> </span><span>type</span><span>=</span><span>\"</span><span>module</span><span>\"</span><span> </span><span>src</span><span>=</span><span>\"</span><span>/@app/index.js</span><span>\"</span><span>&gt;&lt;/</span><span>script</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><p><!--[-->Parsing the Native-ES-Module means it will read the <code><!--[-->export<!--]--></code> and <code><!--[-->import<!--]--></code> lines from your code. It will convert those\nlines into HTTP requests back to the server, where it will again read the <code><!--[-->export<!--]--></code> and <code><!--[-->import<!--]--></code> lines and make new requests.<!--]--></p><p><!--[-->It will keep going through like this with your dependencies recursively, in a waterfall process, until everything has been resolved.<!--]--></p><figure><img><figcaption>Recursive network requests triggered from the entry - VitePress.</figcaption></figure><h3><a><!--[-->Vite Component Example<!--]--></a></h3><p><!--[-->Let's take a look at how these requests are working in the browser. After I open my app at <code><!--[-->http://localhost:3000<!--]--></code>, the browser has fetched the following <code><!--[-->index.js<!--]--></code> file from the web server:<!--]--></p><div><!--[--><!--[--><pre><code><span><span>import</span><span> </span><span>'</span><span>/@theme/styles/main.scss?import</span><span>'</span><span>;</span></span><span><span>import</span><span> Layout </span><span>from</span><span> </span><span>'</span><span>/@theme/Layout.vue</span><span>'</span><span>;</span></span><span><span>import</span><span> NotFound </span><span>from</span><span> </span><span>'</span><span>/@theme/NotFound.vue</span><span>'</span><span>;</span></span><span><span>import</span><span> CardPost </span><span>from</span><span> </span><span>'</span><span>/@theme/components/CardPost.vue</span><span>'</span><span>;</span></span><span></span><span><span>const</span><span> theme </span><span>=</span><span> {</span></span><span><span>    Layout,</span></span><span><span>    NotFound,</span></span><span><span>    </span><span>enhanceApp</span><span>({ </span><span>app</span><span>, }) {</span></span><span><span>        app.</span><span>component</span><span>(</span><span>'</span><span>CardPost</span><span>'</span><span>, CardPost)</span></span><span><span>    }</span></span><span><span>};</span></span><span><span>export</span><span> </span><span>default</span><span> theme;</span></span></code></pre><!--]--><!--]--></div><div><div><div><svg><path><animate></animate></path><rect><animate></animate></rect></svg></div><div><!--[-->Normally, in webpack, you would have to transpile this code to something legacy browsers can understand. Newer browsers know what to do with it, see <a><!--[-->es6 module dynamic import<!--]--></a>.<!--]--></div></div></div><p><!--[-->Let's drill into that highlighted line which is requesting the CardPost SFC. The browser will turn that import into a request for <code><!--[-->http://localhost:3000/@theme/components/CardPost.vue<!--]--></code>.<!--]--></p><div><!--[--><span>CardPost.vue</span><!--[--><pre><code><span><span>&lt;</span><span>script</span><span>&gt;</span></span><span><span>import</span><span> posts </span><span>from</span><span> </span><span>'</span><span>../../posts</span><span>'</span></span><span></span><span><span>export</span><span> </span><span>default</span><span> {</span></span><span><span>  props</span><span>:</span><span> {</span></span><span><span>    postIndex</span><span>:</span><span> {</span></span><span><span>      type</span><span>:</span><span> </span><span>Number</span><span>,</span></span><span><span>      required</span><span>:</span><span> </span><span>true</span><span>,</span></span><span><span>    }</span></span><span><span>  },</span></span><span><span>  computed</span><span>:</span><span> {</span></span><span><span>    </span><span>post</span><span>() {</span></span><span><span>      </span><span>return</span><span> posts[</span><span>this</span><span>.postIndex]</span></span><span><span>    }</span></span><span><span>  }</span></span><span><span>}</span></span><span><span>&lt;/</span><span>script</span><span>&gt;</span></span><span></span><span><span>&lt;</span><span>template</span><span>&gt;</span></span><span><span>  &lt;</span><span>div</span><span> </span><span>class</span><span>=</span><span>\"</span><span>card-post</span><span>\"</span><span>&gt;</span></span><span><span>    ...</span></span><span><span>  &lt;/</span><span>div</span><span>&gt;</span></span><span><span>&lt;/</span><span>template</span><span>&gt;</span></span><span></span><span><span>&lt;</span><span>style</span><span> </span><span>lang</span><span>=</span><span>\"</span><span>scss</span><span>\"</span><span> </span><span>scoped</span><span>&gt;</span></span><span><span>.</span><span>card-post</span><span> {</span></span><span><span>  ...</span></span><span><span>}</span></span><span><span>&lt;/</span><span>style</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><p><!--[-->Once the web server gets this request, it will need to compile the <code><!--[-->CardPost.vue<!--]--></code> file to javascript and send it back. Vite has many\noptimisations around the Vue compiling so this takes no time.<!--]--></p><p><!--[-->Let's see what comes through:<!--]--></p><div><!--[--><span>CardPost.vue - Transpiled</span><!--[--><pre><code><span><span>import</span><span> posts </span><span>from</span><span> </span><span>'</span><span>/.vitepress/posts.ts</span><span>'</span></span><span></span><span><span>import</span><span> </span><span>'</span><span>/@theme/components/CardPost.vue?type=style&amp;index=0</span><span>'</span></span><span><span>import</span><span> { </span><span>render</span><span> </span><span>as</span><span> __render } </span><span>from</span><span> </span><span>'</span><span>/@theme/components/CardPost.vue?type=template</span><span>'</span></span><span></span><span><span>const</span><span> __script </span><span>=</span><span> {</span></span><span><span>  props</span><span>:</span><span> {</span></span><span><span>    postIndex</span><span>:</span><span> {</span></span><span><span>      type</span><span>:</span><span> </span><span>Number</span><span>,</span></span><span><span>      required</span><span>:</span><span> </span><span>true</span><span>,</span></span><span><span>    }</span></span><span><span>  },</span></span><span><span>  computed</span><span>:</span><span> {</span></span><span><span>    </span><span>post</span><span>() {</span></span><span><span>      </span><span>return</span><span> posts[</span><span>this</span><span>.postIndex]</span></span><span><span>    }</span></span><span><span>  }</span></span><span><span>}</span></span><span><span>__script.__scopeId </span><span>=</span><span> </span><span>'</span><span>data-v-287b4794</span><span>'</span></span><span><span>__script.render </span><span>=</span><span> __render</span></span><span><span>__script.__hmrId </span><span>=</span><span> </span><span>'</span><span>/@theme/components/CardPost.vue</span><span>'</span></span><span><span>typeof</span><span> __VUE_HMR_RUNTIME__ </span><span>!==</span><span> </span><span>'</span><span>undefined</span><span>'</span><span> </span><span>&amp;&amp;</span><span> __VUE_HMR_RUNTIME__.</span><span>createRecord</span><span>(__script.__hmrId, __script)</span></span><span><span>__script.__file </span><span>=</span><span> </span><span>'</span><span>/home/harlan/sites/new.harlanzw.com/app/.vitepress/theme/components/CardPost.vue</span><span>'</span></span><span><span>export</span><span> </span><span>default</span><span> __script</span></span></code></pre><!--]--><!--]--></div><p><!--[-->Cool, so quite a bit going on here. The main thing to note here is how it's split up the SFC into different modules which\nwill need separate requests to fetch. It hasn't bundled these imports into the SFC or some other monolith file.<!--]--></p><ul><!--[--><li><!--[-->Dependencies: <code><!--[-->/.vitepress/posts.ts<!--]--></code><!--]--></li><li><!--[-->Template: <code><!--[-->/@theme/components/CardPost.vue?type=template<!--]--></code><!--]--></li><li><!--[-->Stylesheet: <code><!--[-->/@theme/components/CardPost.vue?type=style&amp;index=0<!--]--></code><!--]--></li><!--]--></ul><p><!--[-->If you're curious, this is what the style component response looks like, some nifty for sure.<!--]--></p><div><!--[--><span>CardPost.vue - CSS</span><!--[--><pre><code><span><span>import</span><span> { updateStyle } </span><span>from</span><span> </span><span>'</span><span>/vite/client</span><span>'</span></span><span><span>const</span><span> css </span><span>=</span><span> </span><span>'</span><span>.card-post[data-v-287b4794] {</span><span>\\n</span><span>  position: relative;</span><span>\\n</span><span>}</span><span>\\n</span><span>.card-post .prose[data-v-287b4794] {</span><span>\\n</span><span>  max-width: 100% !important;</span><span>\\n</span><span>}</span><span>\\n</span><span>.card-post__link[data-v-287b4794] {</span><span>\\n</span><span>  position: absolute;</span><span>\\n</span><span>  left: 0;</span><span>\\n</span><span>  top: 0;</span><span>\\n</span><span>  width: 100%;</span><span>\\n</span><span>  height: 100%;</span><span>\\n</span><span>  content: \" \";</span><span>\\n</span><span>  z-index: 1;</span><span>\\n</span><span>}</span><span>\\n</span><span>.card-post__content[data-v-287b4794] {</span><span>\\n</span><span>  background-color: white;</span><span>\\n</span><span>  z-index: 1;</span><span>\\n</span><span>}</span><span>\\n</span><span>.card-post__effect[data-v-287b4794] {</span><span>\\n</span><span>  z-index: -1;</span><span>\\n</span><span>  content: \" \";</span><span>\\n</span><span>  height: 30px;</span><span>\\n</span><span>  width: 100%;</span><span>\\n</span><span>  position: absolute;</span><span>\\n</span><span>  background-color: #059669;</span><span>\\n</span><span>  transition: 0.2s;</span><span>\\n</span><span>  opacity: 0;</span><span>\\n</span><span>  top: 30px;</span><span>\\n</span><span>}</span><span>\\n</span><span>.card-post:hover .card-post__effect[data-v-287b4794] {</span><span>\\n</span><span>  top: -5px;</span><span>\\n</span><span>  opacity: 1;</span><span>\\n</span><span>  transform: rotate(0.25deg);</span><span>\\n</span><span>}</span><span>'</span></span><span><span>updateStyle</span><span>(</span><span>'</span><span>287b4794-0</span><span>'</span><span>, css)</span></span><span><span>export</span><span> </span><span>default</span><span> css</span></span></code></pre><!--]--><!--]--></div><p><!--[-->You can see how the above allows the Hot Module Replacement to work efficiently. When you have a module that is changed,\nsay the styles within a component, instead of reloading the entire component tree, only the style module needs to be replaced.<!--]--></p><p><!--[-->You can also imagine with the above, where Vite slows down. Imagine hundreds of HTTP requests which rely on nested HTTP requests, recursively.\nFortunately, there are optimisation to avoid this situation after the first load. The server will return a 304\nUnmodified HTTP Status code for modules which haven't changed, meaning they will use the browser's cached version of the file.<!--]--></p><p><!--[-->Vite scales well for any app size because it only needs to request the modules for the route you're on.<!--]--></p><h2><a><!--[-->Production Builds<!--]--></a></h2><p><!--[-->Since Vite is using Rollup, pre-configured, you'd expect a similar output from Vite as webpack. Vite does boast a quicker\nbuilder and potentially a smaller artifact size, as Rollup is a more efficient bundler than webpack.<!--]--></p><p><!--[-->The main gotcha is that Vite can still only support ES Modules in the production build, meaning you can't have any dependencies\nwhich don't have ES Module exports.<!--]--></p><p><!--[-->Vite is also pre-configured to handle your build as a universal app. A universal app is built using a client (virtual browser)\nand a server (node). Allowing it to pre-render the HTML pages, so robot crawlers can fetch your page content without executing\njs and speeding up the initial load for users. That means SEO friendly static sites out of the box üéâ.<!--]--></p><h2><a><!--[-->Summary<!--]--></a></h2><p><!--[-->While I haven't touched on a lot of the complexities of Vite and webpack, I've tried to show you the main difference, how\nbundling and no-bundling look in action.<!--]--></p><p><!--[-->Hopefully you've seen why Vite is promising alternative. There is so much potential in the ecosystem at the moment, watch this space, given 12-months we could see an explosion of Vite related projects.<!--]--></p><p><!--[-->If you want to find out more about Vite, I'd watch Evan's talk on <a><!--[-->Vite &amp; VitePress<!--]--></a>.<!--]--></p><h2><a><!--[-->Getting started with Vite<!--]--></a></h2><p><!--[-->I'd recommend just spinning up bare-bones Vite to get a feel for it. It's really easy, takes less than a minute.<!--]--></p><div><!--[--><span>bash</span><!--[--><pre><code><span><span>npm init vite-app</span></span></code></pre><!--]--><!--]--></div><p><!--[-->Once you are sold, it's worth checking out <a><!--[-->the ecosystem<!--]--></a> before you build.<!--]--></p><h3><a><!--[-->Recommendations<!--]--></a></h3><div><div><div><svg><path><animate></animate></path><rect><animate></animate></rect></svg></div><div><!--[-->You shouldn't be looking to replace Vue CLI or webpack with Vite for existing projects yet, but it may be valuable to check out for new smaller scoped projects.<!--]--></div></div></div><p><!--[-->The Vite ecosystem isn't that mature yet, the two main projects I'd recommend checking out are <a><!--[-->VitePress<!--]--></a> and <a><!--[-->Vitesse<!--]--></a>.<!--]--></p><p><!--[-->If you are in need of a documentation site then VitePress is awesome, you can follow the VuePress documentation to fill in any gaps. VitePress abstracts away\nthe Vite configuration, which will be limiting for non-documentation sites.<!--]--></p><p><!--[-->Otherwise, I'd choose Vitesse as it's going to give you more flexible on customising your app. Vitesse offers a pre-configured <code><!--[-->vite.config.js<!--]--></code>, so you can easily\nstrip anything out you don't need to add whatever you'd like to it.<!--]--></p><p><!--[-->If you like my blog (VitePress + TailwindCSS), then you're more than welcome to <a><!--[-->clone it<!--]--></a>.<!--]--></p><h2><a><!--[-->Thanks for reading<!--]--></a></h2><p><!--[-->If you like the technical side of Vue and Laravel, I'll be posting regular articles on this site. The best\nway to keep up to date is by following me <a><!--[-->@harlan_zw<!--]--></a>.<!--]--></p></div><!--]-->",
            "url": "nuxt-blog-azure.vercel.app/blog/how-the-heck-does-vite-work-2",
            "title": "How Does Vite Work - A Comparison to webpack - 2",
            "summary": "A deep-dive into the comparisons between the earliest Vite version and webpack. Discover what I learnt digging into internals and how I, correctly, guessed Vite was the next big thing.",
            "image": "https://harlanzw.com/social/how-vite-works.png",
            "date_modified": "2020-12-01T00:00:00.000Z",
            "author": {
                "name": "AnyBlog"
            }
        },
        {
            "id": "nuxt-blog-azure.vercel.app/blog/how-the-heck-does-vite-work",
            "content_html": "<div><div><div><div><svg><path><animate></animate></path><rect><animate></animate></rect></svg></div><div><!--[-->Note: This article was written for the alpha of Vite. I'd recommend reading Patak's great article on <a><!--[-->The Vite Ecosystem<!--]--></a>.<!--]--></div></div></div><p><!--[-->In rebuilding my old Nuxt.js personal site, I wanted to challenge myself to learn the latest tech, the unknown.<!--]--></p><p><!--[-->The unknown was the new project by Evan You: <a><!--[-->‚ö° Vite<!--]--></a> (/veet/). Called Fast, for the üá´üá∑ Frenchies.<!--]--></p><p><!--[-->I'll be comparing how Vite works to the standard <a><!--[-->webpack<!--]--></a> config using <a><!--[-->webpack-dev-server<!--]--></a>, which all major Vue frameworks\nare using.<!--]--></p><p><!--[-->We'll be looking at how Vite no-bundling works, by first looking at how webpack's bundling works and what the difference is. Afterwards I'll give you some\nrecommendations for setting up Vite for yourself.<!--]--></p><p><!--[-->Vite could the next best thing in tooling, currently, it's still in a pre-release stage though so be careful out there üêõ.<!--]--></p><h2><a><!--[-->A Recap on Vite<!--]--></a></h2><p><!--[-->Vite is a web development build tool which supports Vue, React and Preact. It's an experimental new direction in how build tools can work with a greenfield ecosystem.<!--]--></p><p><!--[-->Vite's core functionality is similar to webpack + webpack-dev-server with some core improvements\non developer experience:<!--]--></p><ul><!--[--><li><!--[-->‚åõ Less time waiting for your app to start, regardless of app size<!--]--></li><li><!--[-->üî• Hot module reloading (HMR) that is basically instant, regardless of app size<!--]--></li><li><!--[-->üî® On-demand compilation<!--]--></li><li><!--[-->üôÖ‚Äç‚ôÇÔ∏è Zero configuration for numerous pre-processors out of the box<!--]--></li><li><!--[-->üìú Esbuild powered typescript / jsx (super quick)<!--]--></li><!--]--></ul><h3><a><!--[-->Speed Example<!--]--></a></h3><p><!--[-->To give you a quick idea on how much faster it is, the below comparison is for Vue CLI which uses webpack. The bigger your app\nis the more noticeable the speed difference will be.<!--]--></p><figure><table><!--[--><thead><!--[--><tr><!--[--><th><!--[--><!--]--></th><th><!--[-->Build Time<!--]--></th><th><!--[-->Dev Server Start Time<!--]--></th><th><!--[-->Dev Page Load Time<!--]--></th><!--]--></tr><!--]--></thead><tbody><!--[--><tr><!--[--><td><!--[-->Vue CLI<!--]--></td><td><!--[--><span>5.14s</span><!--]--></td><td><!--[--><span>2568ms</span><!--]--></td><td><!--[--><span>320ms</span><!--]--></td><!--]--></tr><tr><!--[--><td><!--[-->Vite<!--]--></td><td><!--[--><span>2.39s</span><!--]--></td><td><!--[--><span>232ms</span>Ô∏è<!--]--></td><td><!--[--><span>379ms</span><!--]--></td><!--]--></tr><!--]--></tbody><!--]--></table><figcaption>New Vue 3 project / 10 components / no Babel / 2nd run, in development.</figcaption></figure><h2><a><!--[-->Vite vs webpack<!--]--></a></h2><p><!--[-->The main functional difference you'll notice with Vite and your webpack app, is how code is served in development and which modules are supported.<!--]--></p><p><!--[-->Don't worry if the below terms don't make sense to you, we'll be exploring them below.<!--]--></p><h3><a><!--[-->webpack (Nuxt.js / Vue CLI / etc)<!--]--></a></h3><ul><!--[--><li><!--[-->Supported Modules: <a><!--[-->ES Modules<!--]--></a>, <a><!--[-->CommonJS<!--]--></a> and <a><!--[-->AMD Modules<!--]--></a><!--]--></li><li><!--[-->Dev Server: Bundled modules served via webpack-dev-server using <a><!--[-->Express.js<!--]--></a> web server<!--]--></li><li><!--[-->Production Build: webpack<!--]--></li><!--]--></ul><h3><a><!--[-->Vite<!--]--></a></h3><ul><!--[--><li><!--[-->Supported Modules: <a><!--[-->ES Modules<!--]--></a><!--]--></li><li><!--[-->Dev Server: Native-ES-Modules, served via Vite using a <a><!--[-->Koa<!--]--></a> web server<!--]--></li><li><!--[-->Production build: <a><!--[-->Rollup<!--]--></a><!--]--></li><!--]--></ul><div><div><div><svg><path><animate></animate></path><rect><animate></animate></rect></svg></div><div><!--[-->Check out Mozilla's <a><!--[-->article<!--]--></a> on ES Modules if they're new to you.<!--]--></div></div></div><h2><a><!--[-->Understanding webpack<!--]--></a></h2><p><!--[-->To understand how Vite works, it's best to look at how webpack works first. Even with its popularly, understanding webpack can be intimidating, so I'll try to keep it simple.<!--]--></p><p><!--[-->webpack is versatile in what you can do with it, but at its core, it will:<!--]--></p><ul><!--[--><li><!--[-->Starting with an entry file, build a tree of your dependencies: all the imports, exports, requires from your code/files<!--]--></li><li><!--[-->Transform / compile modules: think transpiling js for older browsers, turning SCSS into CSS<!--]--></li><li><!--[-->Use algorithms to sort, rewrite and concatenate code<!--]--></li><li><!--[-->Optimise<!--]--></li><!--]--></ul><h3><a><!--[-->webpack In Development<!--]--></a></h3><p><!--[-->Assuming you're using one of the main Vue frameworks, when you start your app in development, it is going to do a few things:<!--]--></p><ol><!--[--><li><!--[-->Bundle all of your code<!--]--></li><li><!--[-->Start the webpack-dev-server, the Express.js web server which will serve the bundled code<!--]--></li><li><!--[-->Setup sockets which will handle the Hot Module Reloading<!--]--></li><!--]--></ol><p><!--[-->As you may notice with your own apps, the bigger they grow, the longer you have to wait to start coding.<!--]--></p><figure><img><figcaption>The Nuxt logo is almost burnt into my monitor at this point.</figcaption></figure><p><!--[-->Bundling in development is quicker because you don't need to do as much with the code, however,\nas your app grows, it will become painfully slow, especially on older machines.<!--]--></p><h3><a><!--[-->webpack Component Example<!--]--></a></h3><p><!--[-->I created a default Vue 3 <a><!--[-->Vue CLI<!--]--></a> project, which has an entry <code><!--[-->App.vue<!--]--></code> file using the <code><!--[-->HelloWorld.vue<!--]--></code> component.\nLet's see how this component gets to my browser.<!--]--></p><p><!--[-->HelloWorld.vue component:<!--]--></p><div><!--[--><span>HelloWorld.vue</span><!--[--><pre><code><span><span>&lt;</span><span>script</span><span>&gt;</span></span><span><span>export</span><span> </span><span>default</span><span> {</span></span><span><span>  props</span><span>:</span><span> {</span></span><span><span>    msg</span><span>:</span><span> </span><span>String</span></span><span><span>  }</span></span><span><span>}</span></span><span><span>&lt;/</span><span>script</span><span>&gt;</span></span><span></span><span><span>&lt;</span><span>template</span><span>&gt;</span></span><span><span>  &lt;</span><span>div</span><span> </span><span>class</span><span>=</span><span>\"</span><span>hello</span><span>\"</span><span>&gt;</span></span><span><span>    &lt;</span><span>h</span><span>1&gt;{{ </span><span>msg</span><span> }}&lt;/</span><span>h</span><span>1&gt;</span></span><span><span>  &lt;/</span><span>div</span><span>&gt;</span></span><span><span>&lt;/</span><span>template</span><span>&gt;</span></span><span></span><span><span>&lt;</span><span>style</span><span> </span><span>scoped</span><span>&gt;</span></span><span><span>h1</span><span> {</span></span><span><span>  </span><span>color</span><span>:</span><span> </span><span>green</span><span>;</span></span><span><span>}</span></span><span><span>&lt;/</span><span>style</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><p><!--[-->When I start my app and visit localhost I get the following HTML from the Express.js server.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>&lt;!</span><span>DOCTYPE</span><span> </span><span>html</span><span>&gt;</span></span><span><span>&lt;</span><span>html</span><span> </span><span>lang</span><span>=</span><span>\"</span><span>en</span><span>\"</span><span>&gt;</span></span><span><span>  &lt;</span><span>head</span><span>&gt;</span></span><span><span>    &lt;</span><span>meta</span><span> </span><span>charset</span><span>=</span><span>\"</span><span>utf-8</span><span>\"</span><span>&gt;</span></span><span><span>    &lt;</span><span>meta</span><span> </span><span>http-equiv</span><span>=</span><span>\"</span><span>X-UA-Compatible</span><span>\"</span><span> </span><span>content</span><span>=</span><span>\"</span><span>IE=edge</span><span>\"</span><span>&gt;</span></span><span><span>    &lt;</span><span>meta</span><span> </span><span>name</span><span>=</span><span>\"</span><span>viewport</span><span>\"</span><span> </span><span>content</span><span>=</span><span>\"</span><span>width=device-width,initial-scale=1.0</span><span>\"</span><span>&gt;</span></span><span><span>  &lt;/</span><span>head</span><span>&gt;</span></span><span><span>  &lt;</span><span>body</span><span>&gt;</span></span><span><span>    &lt;</span><span>div</span><span> </span><span>id</span><span>=</span><span>\"</span><span>app</span><span>\"</span><span>&gt;&lt;/</span><span>div</span><span>&gt;</span></span><span><span>    &lt;</span><span>script</span><span> </span><span>type</span><span>=</span><span>\"</span><span>text/javascript</span><span>\"</span><span> </span><span>src</span><span>=</span><span>\"</span><span>/js/chunk-vendors.js</span><span>\"</span><span>&gt;&lt;/</span><span>script</span><span>&gt;</span></span><span><span>    &lt;</span><span>script</span><span> </span><span>type</span><span>=</span><span>\"</span><span>text/javascript</span><span>\"</span><span> </span><span>src</span><span>=</span><span>\"</span><span>/js/app.js</span><span>\"</span><span>&gt;&lt;/</span><span>script</span><span>&gt;</span></span><span><span>  &lt;/</span><span>body</span><span>&gt;</span></span><span><span>&lt;/</span><span>html</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><p><!--[-->You'll notice we have 2 script files there: <code><!--[-->chunk-vendor.js<!--]--></code> and <code><!--[-->app.js<!--]--></code>. On inspecting them you'd see a lot of gibberish looking code.\nit helps to use the <a><!--[-->webpack-bundle-analyzer<!--]--></a> to see how it works visually.<!--]--></p><h4><a><!--[-->chunk-vendors.js<!--]--></a></h4><p><!--[-->These are third-party modules, usually coming from <code><!--[-->node_modules<!--]--></code>. The two main libraries in here are Vue itself and sockjs which is used for HMR.<!--]--></p><figure><img><figcaption>The two top libraries are Vue.js and Sock.js (For HMR)</figcaption></figure><h4><a><!--[-->app.js<!--]--></a></h4><p><!--[-->This is all the code for my application. It contains components, assets, etc. You'll notice that for an SFC it splits\nit into multiple modules.<!--]--></p><figure><img><figcaption>My app is two components, App.vue and HelloWorld.vue</figcaption></figure><p><!--[-->Taking a quick look at the <code><!--[-->app.js<!--]--></code> file, we can find some of the <code><!--[-->HelloWorld<!--]--></code> component code. As you can see in the above image,\nall parts of the SFC are separate modules: the wrapper, CSS, template, js.<!--]--></p><p><!--[-->The wrapper module is defining and importing the other models, some beautiful code.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>/***/</span><span> </span><span>\"</span><span>./src/components/HelloWorld.vue</span><span>\"</span><span>:</span></span><span><span>/*!***************************************!*\\</span></span><span><span>  !*** ./src/components/HelloWorld.vue ***!</span></span><span><span>  \\***************************************/</span></span><span><span>/*! exports provided: default */</span></span><span><span>/***/</span><span> (</span><span>function</span><span>(</span><span>module</span><span>, </span><span>__webpack_exports__</span><span>, </span><span>__webpack_require__</span><span>) {</span></span><span></span><span><span>\"</span><span>use strict</span><span>\"</span><span>;</span></span><span><span>eval</span><span>(</span><span>\"</span><span>__webpack_require__.r(__webpack_exports__);</span><span>\\n</span><span>/* harmony import */ var _HelloWorld_vue_vue_type_template_id_469af010_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HelloWorld.vue?vue&amp;type=template&amp;id=469af010&amp;scoped=true */ </span><span>\\\"</span><span>./src/components/HelloWorld.vue?vue&amp;type=template&amp;id=469af010&amp;scoped=true</span><span>\\\"</span><span>);</span><span>\\n</span><span>/* harmony import */ var _HelloWorld_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./HelloWorld.vue?vue&amp;type=script&amp;lang=js */ </span><span>\\\"</span><span>./src/components/HelloWorld.vue?vue&amp;type=script&amp;lang=js</span><span>\\\"</span><span>);</span><span>\\n</span><span>/* empty/unused harmony star reexport *//* harmony import */ var _HelloWorld_vue_vue_type_style_index_0_id_469af010_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HelloWorld.vue?vue&amp;type=style&amp;index=0&amp;id=469af010&amp;scoped=true&amp;lang=css */ </span><span>\\\"</span><span>./src/components/HelloWorld.vue?vue&amp;type=style&amp;index=0&amp;id=469af010&amp;scoped=true&amp;lang=css</span><span>\\\"</span><span>);</span><span>\\n\\n\\n\\n\\n\\n</span><span>_HelloWorld_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__[</span><span>\\\"</span><span>default</span><span>\\\"</span><span>].render = _HelloWorld_vue_vue_type_template_id_469af010_scoped_true__WEBPACK_IMPORTED_MODULE_0__[</span><span>\\\"</span><span>render</span><span>\\\"</span><span>]</span><span>\\n</span><span>_HelloWorld_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__[</span><span>\\\"</span><span>default</span><span>\\\"</span><span>].__scopeId = </span><span>\\\"</span><span>data-v-469af010</span><span>\\\"\\n</span><span>/* hot reload */</span><span>\\n</span><span>if (true) {</span><span>\\n</span><span>  _HelloWorld_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__[</span><span>\\\"</span><span>default</span><span>\\\"</span><span>].__hmrId = </span><span>\\\"</span><span>469af010</span><span>\\\"\\n</span><span>  const api = __VUE_HMR_RUNTIME__</span><span>\\n</span><span>  module.hot.accept()</span><span>\\n</span><span>  if (!api.createRecord('469af010', _HelloWorld_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__[</span><span>\\\"</span><span>default</span><span>\\\"</span><span>])) {</span><span>\\n</span><span>    api.reload('469af010', _HelloWorld_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__[</span><span>\\\"</span><span>default</span><span>\\\"</span><span>])</span><span>\\n</span><span>  }</span><span>\\n</span><span>  </span><span>\\n</span><span>  module.hot.accept(/*! ./HelloWorld.vue?vue&amp;type=template&amp;id=469af010&amp;scoped=true */ </span><span>\\\"</span><span>./src/components/HelloWorld.vue?vue&amp;type=template&amp;id=469af010&amp;scoped=true</span><span>\\\"</span><span>, function(__WEBPACK_OUTDATED_DEPENDENCIES__) { /* harmony import */ _HelloWorld_vue_vue_type_template_id_469af010_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./HelloWorld.vue?vue&amp;type=template&amp;id=469af010&amp;scoped=true */ </span><span>\\\"</span><span>./src/components/HelloWorld.vue?vue&amp;type=template&amp;id=469af010&amp;scoped=true</span><span>\\\"</span><span>);</span><span>\\n</span><span>(() =&gt; {</span><span>\\n</span><span>    api.rerender('469af010', _HelloWorld_vue_vue_type_template_id_469af010_scoped_true__WEBPACK_IMPORTED_MODULE_0__[</span><span>\\\"</span><span>render</span><span>\\\"</span><span>])</span><span>\\n</span><span>  })(__WEBPACK_OUTDATED_DEPENDENCIES__); }.bind(this))</span><span>\\n\\n</span><span>}</span><span>\\n\\n</span><span>_HelloWorld_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__[</span><span>\\\"</span><span>default</span><span>\\\"</span><span>].__file = </span><span>\\\"</span><span>src/components/HelloWorld.vue</span><span>\\\"\\n\\n</span><span>/* harmony default export */ __webpack_exports__[</span><span>\\\"</span><span>default</span><span>\\\"</span><span>] = (_HelloWorld_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_1__[</span><span>\\\"</span><span>default</span><span>\\\"</span><span>]);</span><span>\"</span><span>);</span></span></code></pre><!--]--><!--]--></div><p><!--[-->The main takeaway here is that within the <code><!--[-->app.js<!--]--></code> file contains all modules for my app.<!--]--></p><p><!--[-->webpack does let you chunk the bundles how you like, for Nuxt.js it chunks routes individually. The more chunks though,\nthe more requests and more potential blocking js.<!--]--></p><p><!--[-->You may see the problem here, we have multiple monolith files that need to be generated anytime we want to use our app.\nWhen we change a file for HMR, we need to regenerate the entire file.<!--]--></p><h2><a><!--[-->Understanding Vite<!--]--></a></h2><p><!--[-->Vite doesn't set out to be a new bundler. Rather, it's a pre-configured build environment using the Rollup\nbundler and a tool for local development.<!--]--></p><h3><a><!--[-->Vite In Development<!--]--></a></h3><p><!--[-->Vite makes the assumption that developers are going to be using the latest browser versions, so it can safely rely on the\nlatest JS functionality straight from the browser - in other words, no babel transpiling!<!--]--></p><p><!--[-->When you start Vite for the first time pre-optimisations will be done on your <code><!--[-->node_modules<!--]--></code>, then <a><!--[-->Koa<!--]--></a>,\na light-weight node web server starts to serve your app.<!--]--></p><p><!--[-->There is no bundling or compiling needed to start the dev server, so it's damn quick (&lt; 300ms).<!--]--></p><p><!--[-->When you open your Vite app you'll be served the <code><!--[-->index.html<!--]--></code> from the server. The browser is going to read the <code><!--[-->index.html<!--]--></code>\nand know how to parse the Native-ES-Module code.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>&lt;</span><span>script</span><span> </span><span>type</span><span>=</span><span>\"</span><span>module</span><span>\"</span><span>&gt;</span><span>import</span><span> </span><span>\"</span><span>/vite/client</span><span>\"</span><span>&lt;/script&gt;</span></span><span><span>&lt;</span><span>div</span><span> </span><span>id</span><span>=</span><span>\"</span><span>app</span><span>\"</span><span>&gt;&lt;/</span><span>div</span><span>&gt;</span></span><span><span>&lt;</span><span>script</span><span> </span><span>type</span><span>=</span><span>\"</span><span>module</span><span>\"</span><span> </span><span>src</span><span>=</span><span>\"</span><span>/@app/index.js</span><span>\"</span><span>&gt;&lt;/</span><span>script</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><p><!--[-->Parsing the Native-ES-Module means it will read the <code><!--[-->export<!--]--></code> and <code><!--[-->import<!--]--></code> lines from your code. It will convert those\nlines into HTTP requests back to the server, where it will again read the <code><!--[-->export<!--]--></code> and <code><!--[-->import<!--]--></code> lines and make new requests.<!--]--></p><p><!--[-->It will keep going through like this with your dependencies recursively, in a waterfall process, until everything has been resolved.<!--]--></p><figure><img><figcaption>Recursive network requests triggered from the entry - VitePress.</figcaption></figure><h3><a><!--[-->Vite Component Example<!--]--></a></h3><p><!--[-->Let's take a look at how these requests are working in the browser. After I open my app at <code><!--[-->http://localhost:3000<!--]--></code>, the browser has fetched the following <code><!--[-->index.js<!--]--></code> file from the web server:<!--]--></p><div><!--[--><!--[--><pre><code><span><span>import</span><span> </span><span>'</span><span>/@theme/styles/main.scss?import</span><span>'</span><span>;</span></span><span><span>import</span><span> Layout </span><span>from</span><span> </span><span>'</span><span>/@theme/Layout.vue</span><span>'</span><span>;</span></span><span><span>import</span><span> NotFound </span><span>from</span><span> </span><span>'</span><span>/@theme/NotFound.vue</span><span>'</span><span>;</span></span><span><span>import</span><span> CardPost </span><span>from</span><span> </span><span>'</span><span>/@theme/components/CardPost.vue</span><span>'</span><span>;</span></span><span></span><span><span>const</span><span> theme </span><span>=</span><span> {</span></span><span><span>    Layout,</span></span><span><span>    NotFound,</span></span><span><span>    </span><span>enhanceApp</span><span>({ </span><span>app</span><span>, }) {</span></span><span><span>        app.</span><span>component</span><span>(</span><span>'</span><span>CardPost</span><span>'</span><span>, CardPost)</span></span><span><span>    }</span></span><span><span>};</span></span><span><span>export</span><span> </span><span>default</span><span> theme;</span></span></code></pre><!--]--><!--]--></div><div><div><div><svg><path><animate></animate></path><rect><animate></animate></rect></svg></div><div><!--[-->Normally, in webpack, you would have to transpile this code to something legacy browsers can understand. Newer browsers know what to do with it, see <a><!--[-->es6 module dynamic import<!--]--></a>.<!--]--></div></div></div><p><!--[-->Let's drill into that highlighted line which is requesting the CardPost SFC. The browser will turn that import into a request for <code><!--[-->http://localhost:3000/@theme/components/CardPost.vue<!--]--></code>.<!--]--></p><div><!--[--><span>CardPost.vue</span><!--[--><pre><code><span><span>&lt;</span><span>script</span><span>&gt;</span></span><span><span>import</span><span> posts </span><span>from</span><span> </span><span>'</span><span>../../posts</span><span>'</span></span><span></span><span><span>export</span><span> </span><span>default</span><span> {</span></span><span><span>  props</span><span>:</span><span> {</span></span><span><span>    postIndex</span><span>:</span><span> {</span></span><span><span>      type</span><span>:</span><span> </span><span>Number</span><span>,</span></span><span><span>      required</span><span>:</span><span> </span><span>true</span><span>,</span></span><span><span>    }</span></span><span><span>  },</span></span><span><span>  computed</span><span>:</span><span> {</span></span><span><span>    </span><span>post</span><span>() {</span></span><span><span>      </span><span>return</span><span> posts[</span><span>this</span><span>.postIndex]</span></span><span><span>    }</span></span><span><span>  }</span></span><span><span>}</span></span><span><span>&lt;/</span><span>script</span><span>&gt;</span></span><span></span><span><span>&lt;</span><span>template</span><span>&gt;</span></span><span><span>  &lt;</span><span>div</span><span> </span><span>class</span><span>=</span><span>\"</span><span>card-post</span><span>\"</span><span>&gt;</span></span><span><span>    ...</span></span><span><span>  &lt;/</span><span>div</span><span>&gt;</span></span><span><span>&lt;/</span><span>template</span><span>&gt;</span></span><span></span><span><span>&lt;</span><span>style</span><span> </span><span>lang</span><span>=</span><span>\"</span><span>scss</span><span>\"</span><span> </span><span>scoped</span><span>&gt;</span></span><span><span>.</span><span>card-post</span><span> {</span></span><span><span>  ...</span></span><span><span>}</span></span><span><span>&lt;/</span><span>style</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><p><!--[-->Once the web server gets this request, it will need to compile the <code><!--[-->CardPost.vue<!--]--></code> file to javascript and send it back. Vite has many\noptimisations around the Vue compiling so this takes no time.<!--]--></p><p><!--[-->Let's see what comes through:<!--]--></p><div><!--[--><span>CardPost.vue - Transpiled</span><!--[--><pre><code><span><span>import</span><span> posts </span><span>from</span><span> </span><span>'</span><span>/.vitepress/posts.ts</span><span>'</span></span><span></span><span><span>import</span><span> </span><span>'</span><span>/@theme/components/CardPost.vue?type=style&amp;index=0</span><span>'</span></span><span><span>import</span><span> { </span><span>render</span><span> </span><span>as</span><span> __render } </span><span>from</span><span> </span><span>'</span><span>/@theme/components/CardPost.vue?type=template</span><span>'</span></span><span></span><span><span>const</span><span> __script </span><span>=</span><span> {</span></span><span><span>  props</span><span>:</span><span> {</span></span><span><span>    postIndex</span><span>:</span><span> {</span></span><span><span>      type</span><span>:</span><span> </span><span>Number</span><span>,</span></span><span><span>      required</span><span>:</span><span> </span><span>true</span><span>,</span></span><span><span>    }</span></span><span><span>  },</span></span><span><span>  computed</span><span>:</span><span> {</span></span><span><span>    </span><span>post</span><span>() {</span></span><span><span>      </span><span>return</span><span> posts[</span><span>this</span><span>.postIndex]</span></span><span><span>    }</span></span><span><span>  }</span></span><span><span>}</span></span><span><span>__script.__scopeId </span><span>=</span><span> </span><span>'</span><span>data-v-287b4794</span><span>'</span></span><span><span>__script.render </span><span>=</span><span> __render</span></span><span><span>__script.__hmrId </span><span>=</span><span> </span><span>'</span><span>/@theme/components/CardPost.vue</span><span>'</span></span><span><span>typeof</span><span> __VUE_HMR_RUNTIME__ </span><span>!==</span><span> </span><span>'</span><span>undefined</span><span>'</span><span> </span><span>&amp;&amp;</span><span> __VUE_HMR_RUNTIME__.</span><span>createRecord</span><span>(__script.__hmrId, __script)</span></span><span><span>__script.__file </span><span>=</span><span> </span><span>'</span><span>/home/harlan/sites/new.harlanzw.com/app/.vitepress/theme/components/CardPost.vue</span><span>'</span></span><span><span>export</span><span> </span><span>default</span><span> __script</span></span></code></pre><!--]--><!--]--></div><p><!--[-->Cool, so quite a bit going on here. The main thing to note here is how it's split up the SFC into different modules which\nwill need separate requests to fetch. It hasn't bundled these imports into the SFC or some other monolith file.<!--]--></p><ul><!--[--><li><!--[-->Dependencies: <code><!--[-->/.vitepress/posts.ts<!--]--></code><!--]--></li><li><!--[-->Template: <code><!--[-->/@theme/components/CardPost.vue?type=template<!--]--></code><!--]--></li><li><!--[-->Stylesheet: <code><!--[-->/@theme/components/CardPost.vue?type=style&amp;index=0<!--]--></code><!--]--></li><!--]--></ul><p><!--[-->If you're curious, this is what the style component response looks like, some nifty for sure.<!--]--></p><div><!--[--><span>CardPost.vue - CSS</span><!--[--><pre><code><span><span>import</span><span> { updateStyle } </span><span>from</span><span> </span><span>'</span><span>/vite/client</span><span>'</span></span><span><span>const</span><span> css </span><span>=</span><span> </span><span>'</span><span>.card-post[data-v-287b4794] {</span><span>\\n</span><span>  position: relative;</span><span>\\n</span><span>}</span><span>\\n</span><span>.card-post .prose[data-v-287b4794] {</span><span>\\n</span><span>  max-width: 100% !important;</span><span>\\n</span><span>}</span><span>\\n</span><span>.card-post__link[data-v-287b4794] {</span><span>\\n</span><span>  position: absolute;</span><span>\\n</span><span>  left: 0;</span><span>\\n</span><span>  top: 0;</span><span>\\n</span><span>  width: 100%;</span><span>\\n</span><span>  height: 100%;</span><span>\\n</span><span>  content: \" \";</span><span>\\n</span><span>  z-index: 1;</span><span>\\n</span><span>}</span><span>\\n</span><span>.card-post__content[data-v-287b4794] {</span><span>\\n</span><span>  background-color: white;</span><span>\\n</span><span>  z-index: 1;</span><span>\\n</span><span>}</span><span>\\n</span><span>.card-post__effect[data-v-287b4794] {</span><span>\\n</span><span>  z-index: -1;</span><span>\\n</span><span>  content: \" \";</span><span>\\n</span><span>  height: 30px;</span><span>\\n</span><span>  width: 100%;</span><span>\\n</span><span>  position: absolute;</span><span>\\n</span><span>  background-color: #059669;</span><span>\\n</span><span>  transition: 0.2s;</span><span>\\n</span><span>  opacity: 0;</span><span>\\n</span><span>  top: 30px;</span><span>\\n</span><span>}</span><span>\\n</span><span>.card-post:hover .card-post__effect[data-v-287b4794] {</span><span>\\n</span><span>  top: -5px;</span><span>\\n</span><span>  opacity: 1;</span><span>\\n</span><span>  transform: rotate(0.25deg);</span><span>\\n</span><span>}</span><span>'</span></span><span><span>updateStyle</span><span>(</span><span>'</span><span>287b4794-0</span><span>'</span><span>, css)</span></span><span><span>export</span><span> </span><span>default</span><span> css</span></span></code></pre><!--]--><!--]--></div><p><!--[-->You can see how the above allows the Hot Module Replacement to work efficiently. When you have a module that is changed,\nsay the styles within a component, instead of reloading the entire component tree, only the style module needs to be replaced.<!--]--></p><p><!--[-->You can also imagine with the above, where Vite slows down. Imagine hundreds of HTTP requests which rely on nested HTTP requests, recursively.\nFortunately, there are optimisation to avoid this situation after the first load. The server will return a 304\nUnmodified HTTP Status code for modules which haven't changed, meaning they will use the browser's cached version of the file.<!--]--></p><p><!--[-->Vite scales well for any app size because it only needs to request the modules for the route you're on.<!--]--></p><h2><a><!--[-->Production Builds<!--]--></a></h2><p><!--[-->Since Vite is using Rollup, pre-configured, you'd expect a similar output from Vite as webpack. Vite does boast a quicker\nbuilder and potentially a smaller artifact size, as Rollup is a more efficient bundler than webpack.<!--]--></p><p><!--[-->The main gotcha is that Vite can still only support ES Modules in the production build, meaning you can't have any dependencies\nwhich don't have ES Module exports.<!--]--></p><p><!--[-->Vite is also pre-configured to handle your build as a universal app. A universal app is built using a client (virtual browser)\nand a server (node). Allowing it to pre-render the HTML pages, so robot crawlers can fetch your page content without executing\njs and speeding up the initial load for users. That means SEO friendly static sites out of the box üéâ.<!--]--></p><h2><a><!--[-->Summary<!--]--></a></h2><p><!--[-->While I haven't touched on a lot of the complexities of Vite and webpack, I've tried to show you the main difference, how\nbundling and no-bundling look in action.<!--]--></p><p><!--[-->Hopefully you've seen why Vite is promising alternative. There is so much potential in the ecosystem at the moment, watch this space, given 12-months we could see an explosion of Vite related projects.<!--]--></p><p><!--[-->If you want to find out more about Vite, I'd watch Evan's talk on <a><!--[-->Vite &amp; VitePress<!--]--></a>.<!--]--></p><h2><a><!--[-->Getting started with Vite<!--]--></a></h2><p><!--[-->I'd recommend just spinning up bare-bones Vite to get a feel for it. It's really easy, takes less than a minute.<!--]--></p><div><!--[--><span>bash</span><!--[--><pre><code><span><span>npm init vite-app</span></span></code></pre><!--]--><!--]--></div><p><!--[-->Once you are sold, it's worth checking out <a><!--[-->the ecosystem<!--]--></a> before you build.<!--]--></p><h3><a><!--[-->Recommendations<!--]--></a></h3><div><div><div><svg><path><animate></animate></path><rect><animate></animate></rect></svg></div><div><!--[-->You shouldn't be looking to replace Vue CLI or webpack with Vite for existing projects yet, but it may be valuable to check out for new smaller scoped projects.<!--]--></div></div></div><p><!--[-->The Vite ecosystem isn't that mature yet, the two main projects I'd recommend checking out are <a><!--[-->VitePress<!--]--></a> and <a><!--[-->Vitesse<!--]--></a>.<!--]--></p><p><!--[-->If you are in need of a documentation site then VitePress is awesome, you can follow the VuePress documentation to fill in any gaps. VitePress abstracts away\nthe Vite configuration, which will be limiting for non-documentation sites.<!--]--></p><p><!--[-->Otherwise, I'd choose Vitesse as it's going to give you more flexible on customising your app. Vitesse offers a pre-configured <code><!--[-->vite.config.js<!--]--></code>, so you can easily\nstrip anything out you don't need to add whatever you'd like to it.<!--]--></p><p><!--[-->If you like my blog (VitePress + TailwindCSS), then you're more than welcome to <a><!--[-->clone it<!--]--></a>.<!--]--></p><h2><a><!--[-->Thanks for reading<!--]--></a></h2><p><!--[-->If you like the technical side of Vue and Laravel, I'll be posting regular articles on this site. The best\nway to keep up to date is by following me <a><!--[-->@harlan_zw<!--]--></a>.<!--]--></p></div><!--]-->",
            "url": "nuxt-blog-azure.vercel.app/blog/how-the-heck-does-vite-work",
            "title": "How Does Vite Work - A Comparison to webpack",
            "summary": "A deep-dive into the comparisons between the earliest Vite version and webpack. Discover what I learnt digging into internals and how I, correctly, guessed Vite was the next big thing.",
            "image": "https://harlanzw.com/social/how-vite-works.png",
            "date_modified": "2020-12-01T00:00:00.000Z",
            "author": {
                "name": "AnyBlog"
            }
        },
        {
            "id": "nuxt-blog-azure.vercel.app/blog/modern-package-development",
            "content_html": "<div><div><div><div><svg><path><animate></animate></path><rect><animate></animate></rect></svg></div><div><!--[-->This article is a work in progress. Feel free to read it, but some sections are incomplete.<!--]--></div></div></div><h2><a><!--[-->Introduction<!--]--></a></h2><p><!--[--><a><!--[-->Unlighthouse<!--]--></a> is an open-source package I built to scan your entire site using Google Lighthouse.<!--]--></p><p><!--[-->Building it was chaotic, with day-long bugs, constant refactoring and endless documentation reading.<!--]--></p><p><!--[-->Through building it, I learnt modern development practices, making use of the vast ecosystem of packages and tools.<!--]--></p><h2><a><!--[-->Background: Why build Unlighthouse?<!--]--></a></h2><p><!--[-->As a freelancer I  keep on top of my clients organic growth with Google Search Console.<!--]--></p><p><!--[-->Was a day like any other, looking at one of my clients' dashboard. Seemingly out of nowhere, I saw the trend of page position, clicks and page views in free fall. My clients' income was based on organic traffic, not good.<!--]--></p><figure><img><figcaption>Trending down Google Search Console</figcaption></figure><p><!--[-->Isolating the reason for the falling page rank wasn't easy. The site had issues, but what was causing the free fall? There was no easy way to know.<!--]--></p><p><!--[-->To diagnose the issue, I used Google Lighthouse. I went through all pages of the site, noticing quite a number of issues. I spent a couple of days\nfixing them all up and improving the general performance of the site.<!--]--></p><p><!--[-->What happened next? Things started turning around. I was able to invert the graph. Organic growth doubled in the next few months. Happy client.<!--]--></p><figure><img><figcaption>Trending up Google Search Console</figcaption></figure><p><!--[-->Now that was out of the way, how could I make it easier to stay on top of the health of the sites I manage?<!--]--></p><h2><a><!--[-->Deciding on the stack<!--]--></a></h2><p><!--[-->I needed to build a tool that would run Google Lighthouse on an entire site with just the home page URL.<!--]--></p><p><!--[-->I had a plan of attack for the build.<!--]--></p><p><!--[-->The backend would be build using Typescript and Node.<!--]--></p><p><!--[-->The frontend client would be built using Vue and Vite.<!--]--></p><p><!--[-->But how would I be able to design this in a way that was easy to build and maintain?<!--]--></p><p><!--[-->I had seen the amazing work coming out of the <a><!--[-->UnJS<!--]--></a> ecosystem and knew that they could solve some of my problems.<!--]--></p><p><!--[-->With that, the package would be known as <strong><!--[-->Un<!--]--></strong> (inspired by Unjs) <strong><!--[-->Lighthouse<!--]--></strong>.<!--]--></p><p><!--[-->Keeping a keen eye on other modern packages coming out, I took some of the best practices and tools I saw implemented.<!--]--></p><p><!--[-->The stack was split into three core parts:<!--]--></p><ul><!--[--><li><!--[-->Monorepo: containing the dependencies to build, test and deploy the code<!--]--></li><li><!--[-->Frontend: displaying searchable, filtering and sortable results<!--]--></li><li><!--[-->Backend: generating the frontend, running the scans and providing an API for the frontend<!--]--></li><!--]--></ul><h2><a><!--[-->Monorepo<!--]--></a></h2><p><!--[-->Implementing a monorepo is a keystone for a large project which will ship multiple packages. It allows you to\ngroup up logic, dependencies and documentation into a single repository.<!--]--></p><h3><a><!--[-->PNPM<!--]--></a></h3><p><!--[--><a><!--[-->PNPM<!--]--></a> is the new kid on the block of node package managers and has gained a large following quickly, for good reason. It is the most performant package manager and has first class support for monorepos.<!--]--></p><p><!--[-->There are many benefits to using a monorepo for a package. My personal favourite is it allows me to easily isolate logic and dependencies for your package, letting you write simpler code. Allowing end users to pull any specific part of your package that they want to use.<!--]--></p><figure><img><figcaption>Unlighthouse monorepo</figcaption></figure><h3><a><!--[-->Vitest<!--]--></a></h3><p><!--[--><a><!--[-->Vitest<!--]--></a> is also the new kid on the block of testing. It's original aim was to be a testing framework specifically for Vite, but it has ended up being a possible replacement for Jest entirely.<!--]--></p><p><!--[-->Vitest makes writing your logic and tests a breeze and I'd recommend checking it out for any project.<!--]--></p><h3><a><!--[-->Unbuild<!--]--></a></h3><figure><img><!----></figure><p><!--[-->This package is described as a \"A unified javascript build system\".<!--]--></p><p><!--[-->In reality, it's a minimal config way to build your package code to ESM and CJS.<!--]--></p><p><!--[-->One of the amazing features of unbuild is stubbing. This allows you can run source code from your dist folder, meaning it transpiles just-in-time.<!--]--></p><p><!--[-->This allows you to completely cut out the build step when you're iterating and testing integrations on your package.<!--]--></p><p><!--[-->It's as simple as <code><!--[-->unbuild --stub<!--]--></code>.<!--]--></p><div><!--[--><span>build.config.ts</span><!--[--><pre><code><span><span>import</span><span> { defineBuildConfig } </span><span>from</span><span> </span><span>'</span><span>unbuild</span><span>'</span></span><span></span><span><span>export</span><span> </span><span>default</span><span> </span><span>defineBuildConfig</span><span>({</span></span><span><span>  entries</span><span>:</span><span> [</span></span><span><span>    { input</span><span>:</span><span> </span><span>'</span><span>src/index</span><span>'</span><span> },</span></span><span><span>    { input</span><span>:</span><span> </span><span>'</span><span>src/process</span><span>'</span><span>, outDir</span><span>:</span><span> </span><span>'</span><span>dist/process</span><span>'</span><span>, builder</span><span>:</span><span> </span><span>'</span><span>mkdist</span><span>'</span><span>, declaration</span><span>:</span><span> </span><span>false</span><span> },</span></span><span><span>  ],</span></span><span><span>})</span></span></code></pre><!--]--><!--]--></div><p><!--[--><a><!--[-->GitHub Repo Link<!--]--></a><!--]--></p><h2><a><!--[-->Server<!--]--></a></h2><h3><a><!--[-->Lighthouse Binary<!--]--></a></h3><p><!--[-->Unlighthouse wouldn't be possible if Google hadn't published Lighthouse as its own <a><!--[-->NPM binary<!--]--></a>.<!--]--></p><p><!--[-->To make Unlighthouse fast, I combined the binary with the package <a><!--[-->puppeteer-cluster<!--]--></a>, which allows for multi-threaded lighthouse scans.<!--]--></p><h3><a><!--[-->Unctx<!--]--></a></h3><figure><img><!----></figure><p><!--[-->It's amazing that a simple pattern like composition has evaded Node packages for so long.<!--]--></p><p><!--[-->With the introduction of Vue 3, composition became cool. And with that, unctx is composition for your own package.<!--]--></p><p><!--[-->unctx allows you to define a scope where there's only a single instance of something that is globally accessible. This is incredibly useful for building packages, as you no longer need to be juggling core state. You can build your logic out as composables that interact with the core.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>import</span><span> { createContext } </span><span>from</span><span> </span><span>'</span><span>unctx</span><span>'</span></span><span></span><span><span>const</span><span> engineContext </span><span>=</span><span> </span><span>createContext</span><span>&lt;</span><span>UnlighthouseContext</span><span>&gt;()</span></span><span></span><span><span>export</span><span> </span><span>const</span><span> useUnlighthouse </span><span>=</span><span> engineContext.use </span><span>as</span><span> () </span><span>=&gt;</span><span> </span><span>UnlighthouseContext</span></span><span></span><span><span>export</span><span> </span><span>const</span><span> </span><span>createUnlighthouse</span><span> </span><span>=</span><span> </span><span>async</span><span> (</span><span>userConfig</span><span>:</span><span> </span><span>UserConfig</span><span>, </span><span>provider</span><span>?:</span><span> </span><span>Provider</span><span>) </span><span>=&gt;</span><span> {</span></span><span><span>  </span><span>// ...</span></span><span><span>  engineContext.</span><span>set</span><span>(ctx, </span><span>true</span><span>)</span></span><span><span>}</span></span></code></pre><!--]--><!--]--></div><ul><!--[--><li><!--[--><a><!--[-->unctx GitHub Repo<!--]--></a><!--]--></li><!--]--></ul><h3><a><!--[-->Hookable<!--]--></a></h3><figure><img><!----></figure><p><!--[-->For Nuxt.js users, you might be familiar with the concept of frameworks hooks. A way for you to modify or do something with the internal logic of Nuxt.<!--]--></p><p><!--[-->Building a package, I knew that this was a useful feature, not just for end-users, but for me as a way to organise logic.<!--]--></p><p><!--[-->Having a core which is hookable means you can avoid baking logic in that may be better suited elsewhere.<!--]--></p><p><!--[-->For example, I wanted to make sure that Unlighthouse didn't start for integrations until they visited the page.<!--]--></p><p><!--[-->I simply set a hook for it to start only when they visit the client.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>hooks.</span><span>hookOnce</span><span>(</span><span>'</span><span>visited-client</span><span>'</span><span>, () </span><span>=&gt;</span><span> {</span></span><span><span>  ctx.</span><span>start</span><span>()</span></span><span><span>})</span></span></code></pre><!--]--><!--]--></div><ul><!--[--><li><!--[--><a><!--[-->Hookable GitHub Repo<!--]--></a><!--]--></li><!--]--></ul><h3><a><!--[-->Unconfig<!--]--></a></h3><figure><img><!----></figure><p><!--[-->Unconfig is a universal solution for loading configurations. This let me allow the package to load in a configuration from <code><!--[-->unlighthouse.config.ts<!--]--></code> or a custom path, with barely any code.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>import</span><span> { loadConfig } </span><span>from</span><span> </span><span>'</span><span>unconfig</span><span>'</span></span><span></span><span><span>const</span><span> configDefinition </span><span>=</span><span> </span><span>await</span><span> </span><span>loadConfig</span><span>&lt;</span><span>UserConfig</span><span>&gt;({</span></span><span><span>  cwd</span><span>:</span><span> userConfig.root,</span></span><span><span>  sources</span><span>:</span><span> [</span></span><span><span>    {</span></span><span><span>      files</span><span>:</span><span> [</span></span><span><span>        </span><span>'</span><span>unlighthouse.config</span><span>'</span><span>,</span></span><span><span>        </span><span>// may provide the config file as an argument</span></span><span><span>        </span><span>...</span><span>(userConfig.configFile </span><span>?</span><span> [userConfig.configFile] </span><span>:</span><span> []),</span></span><span><span>      ],</span></span><span><span>      </span><span>// default extensions</span></span><span><span>      extensions</span><span>:</span><span> [</span><span>'</span><span>ts</span><span>'</span><span>, </span><span>'</span><span>js</span><span>'</span><span>],</span></span><span><span>    },</span></span><span><span>  ],</span></span><span><span>})</span></span><span><span>if</span><span> (configDefinition.sources?.[</span><span>0</span><span>]) {</span></span><span><span>  configFile </span><span>=</span><span> configDefinition.sources[</span><span>0</span><span>]</span></span><span><span>  userConfig </span><span>=</span><span> </span><span>defu</span><span>(configDefinition.config, userConfig)</span></span><span><span>}</span></span></code></pre><!--]--><!--]--></div><ul><!--[--><li><!--[--><a><!--[-->Unconfig GitHub Repo<!--]--></a><!--]--></li><!--]--></ul><h3><a><!--[-->ufo<!--]--></a></h3><figure><img><!----></figure><p><!--[-->Dealing with URLs in Node isn't nice. For Unlighthouse I needed to deal with many URLS, I needed to make sure they were standardised no matter how they were formed.<!--]--></p><p><!--[-->This meant using the ufo package heavily. The slash trimming came in handy and the origin detection.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>export</span><span> </span><span>const</span><span> </span><span>trimSlashes</span><span> </span><span>=</span><span> (</span><span>s</span><span>:</span><span> </span><span>string</span><span>) </span><span>=&gt;</span><span> </span><span>withoutLeadingSlash</span><span>(</span><span>withoutTrailingSlash</span><span>(s))</span></span></code></pre><!--]--><!--]--></div><div><!--[--><!--[--><pre><code><span><span>const</span><span> site </span><span>=</span><span> </span><span>new</span><span> </span><span>$URL</span><span>(url).origin</span></span></code></pre><!--]--><!--]--></div><ul><!--[--><li><!--[--><a><!--[-->ufo GitHub Repo<!--]--></a><!--]--></li><!--]--></ul><h3><a><!--[-->Unrouted<!--]--></a></h3><figure><img><!----></figure><p><!--[-->I needed an API for the client to communicate with the Node server to fetch the status of the scan and submit re-scans.<!--]--></p><p><!--[-->The current JS offerings were a bit lackluster. I wanted something that just worked and had a nice way to use it.<!--]--></p><p><!--[-->I ended up building unrouted as a way to solve that.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>group</span><span>(</span><span>'</span><span>/api</span><span>'</span><span>, () </span><span>=&gt;</span><span> {</span></span><span><span>  </span><span>group</span><span>(</span><span>'</span><span>/reports</span><span>'</span><span>, () </span><span>=&gt;</span><span> {</span></span><span><span>    </span><span>post</span><span>(</span><span>'</span><span>/rescan</span><span>'</span><span>, () </span><span>=&gt;</span><span> {</span></span><span><span>      </span><span>// ...</span></span><span><span>      </span><span>return</span><span> </span><span>true</span></span><span><span>    })</span></span><span></span><span><span>    </span><span>post</span><span>(</span><span>'</span><span>/:id/rescan</span><span>'</span><span>, () </span><span>=&gt;</span><span> {</span></span><span><span>      </span><span>const</span><span> report </span><span>=</span><span> </span><span>useReport</span><span>()</span></span><span><span>      </span><span>const</span><span> { worker } </span><span>=</span><span> </span><span>useUnlighthouse</span><span>()</span></span><span></span><span><span>      </span><span>if</span><span> (report)</span></span><span><span>        worker.</span><span>requeueReport</span><span>(report)</span></span><span><span>    })</span></span><span><span>  })</span></span><span></span><span><span>  </span><span>get</span><span>(</span><span>'</span><span>__launch</span><span>'</span><span>, () </span><span>=&gt;</span><span> {</span></span><span><span>    </span><span>const</span><span> { file } </span><span>=</span><span> </span><span>useQuery</span><span>&lt;{ file</span><span>:</span><span> </span><span>string</span><span> }&gt;()</span></span><span><span>    </span><span>if</span><span> (</span><span>!</span><span>file) {</span></span><span><span>      </span><span>setStatusCode</span><span>(</span><span>400</span><span>)</span></span><span><span>      </span><span>return</span><span> </span><span>false</span></span><span><span>    }</span></span><span><span>    </span><span>const</span><span> path </span><span>=</span><span> file.</span><span>replace</span><span>(resolvedConfig.root, </span><span>''</span><span>)</span></span><span><span>    </span><span>const</span><span> resolved </span><span>=</span><span> </span><span>join</span><span>(resolvedConfig.root, path)</span></span><span><span>    logger.</span><span>info</span><span>(</span><span>`Launching file in editor: </span><span>\\`${</span><span>path</span><span>}\\`</span><span>`</span><span>)</span></span><span><span>    </span><span>launch</span><span>(resolved)</span></span><span><span>  })</span></span><span></span><span><span>  </span><span>get</span><span>(</span><span>'</span><span>ws</span><span>'</span><span>, </span><span>req</span><span> </span><span>=&gt;</span><span> ws.</span><span>serve</span><span>(req))</span></span><span></span><span><span>  </span><span>get</span><span>(</span><span>'</span><span>reports</span><span>'</span><span>, () </span><span>=&gt;</span><span> {</span></span><span><span>    </span><span>const</span><span> { worker } </span><span>=</span><span> </span><span>useUnlighthouse</span><span>()</span></span><span></span><span><span>    </span><span>return</span><span> worker.</span><span>reports</span><span>().</span><span>filter</span><span>(</span><span>r</span><span> </span><span>=&gt;</span><span> r.tasks.inspectHtmlTask </span><span>===</span><span> </span><span>'</span><span>completed</span><span>'</span><span>)</span></span><span><span>  })</span></span><span></span><span><span>  </span><span>get</span><span>(</span><span>'</span><span>scan-meta</span><span>'</span><span>, () </span><span>=&gt;</span><span> </span><span>createScanMeta</span><span>())</span></span><span><span>})</span></span></code></pre><!--]--><!--]--></div><ul><!--[--><li><!--[--><a><!--[-->Unrouted GitHub Repo<!--]--></a><!--]--></li><!--]--></ul><h2><a><!--[-->Client<!--]--></a></h2><p><!--[-->The code that what went into building the package.<!--]--></p><h3><a><!--[-->Vue 3 / Vite client<!--]--></a></h3><p><!--[-->The beloved <a><!--[-->Vite<!--]--></a> was to be used to make the development of the client as easy and fast as possible.<!--]--></p><p><!--[-->Vue v3 used to make use of the vast collection of utilities available at <a><!--[-->VueUse<!--]--></a>.<!--]--></p><h2><a><!--[-->Putting It Together - Part 2<!--]--></a></h2><p><!--[-->Part 2 of this article will be coming soon where I go over some technical feats in putting together the above packages.<!--]--></p><h2><a><!--[-->Conclusion<!--]--></a></h2><p><!--[-->Thanks for reading Part 1. I hope you at least found it interesting or some of the links useful.<!--]--></p></div><!--]-->",
            "url": "nuxt-blog-azure.vercel.app/blog/modern-package-development",
            "title": "Learning Modern Package Development: Monorepos and Backends - Part 1",
            "summary": "Discover how you can build a modern package development through how I created the Unlighthouse project.",
            "image": "https://next.unlighthouse.dev/og.png",
            "date_modified": "2022-07-31T00:00:00.000Z",
            "author": {
                "name": "AnyBlog"
            }
        },
        {
            "id": "nuxt-blog-azure.vercel.app/blog/scale-your-vue-components",
            "content_html": "<div><p><!--[-->One of the key pieces in scaling your Vue app is having good component architecture.<!--]--></p><ul><!--[--><li><!--[-->How are components named?<!--]--></li><li><!--[-->What folder hierarchy should you use?<!--]--></li><li><!--[-->How is component code scoped?<!--]--></li><!--]--></ul><p><!--[-->The cost of not having clear answers to these simple questions increases as your app grows.<!--]--></p><p><!--[-->My previous role was the tech lead at a startup. Growing pains were frequent with pivots, design changes and new features. All pushing our total component count up.<!--]--></p><p><!--[-->My below suggestions are what I came up with to solve <em><!--[-->our<!--]--></em> scaling issues. Your project will have its own requirements.<!--]--></p><h2><a><!--[-->100+ component club<!--]--></a></h2><p><!--[-->Let's assume once you hit 100+ components, then you are a mid-size app and you will be feeling your own growing pains.<!--]--></p><p><!--[-->Are you in the club? Run the following in your component folder:<!--]--></p><div><!--[--><!--[--><pre><code><span><span># cd app/components</span></span><span><span>COMPONENTS=</span><span>$(</span><span>ls -lR </span><span>**</span><span>/</span><span>*</span><span>.vue </span><span>|</span><span> wc -l</span><span>)</span><span> </span><span>&amp;&amp;</span><span> </span><span>echo</span><span> -e </span><span>\"</span><span>You have </span><span>${COMPONENTS}</span><span> components.</span><span>\"</span></span></code></pre><!--]--><!--]--></div><h3><a><!--[-->Problems you may have<!--]--></a></h3><ul><!--[--><li><!--[-->Difficult to remember which component to use where<!--]--></li><li><!--[-->Code is being repeated<!--]--></li><li><!--[-->Monolithic components<!--]--></li><li><!--[-->New components are being built instead of leveraging existing ones<!--]--></li><li><!--[-->Inconsistent emits and props between components with the same functionality<!--]--></li><li><!--[-->Technical debt is being ignored because it is too painful<!--]--></li><!--]--></ul><h2><a><!--[-->Solving component scaling with rules<!--]--></a></h2><p><!--[-->Good code adheres to a set of rules. You either follow existing rules (syntax and conventions) or create\nnew ones and make sure others follow them (documentation and code reviews).<!--]--></p><h3><a><!--[-->Rule 0. Have good dev processes<!--]--></a></h3><p><!--[-->There is no substitute for a good development process. You need to be following best continuous delivery, documentation and communication practices.\nThe rest of the rules will not help you if you are not functioning like a well-oiled machine.<!--]--></p><h3><a><!--[-->Rule 1. Know the style guide<!--]--></a></h3><p><!--[-->You should be familiar with the official <a><!--[-->Vue.js Style Guide<!--]--></a>.\nIt gives you clear, concise instructions on what you should and shouldn't do.\nYou should set up <a><!--[-->eslint-plugin-vue<!--]--></a> with the recommended rules.<!--]--></p><div><!--[--><span>.eslintrc.js</span><!--[--><pre><code><span><span>module</span><span>.</span><span>exports</span><span> </span><span>=</span><span> {</span></span><span><span>  extends</span><span>:</span><span> [</span></span><span><span>    </span><span>// ...</span></span><span><span>    </span><span>'</span><span>plugin:vue/vue3-recommended</span><span>'</span><span>,</span></span><span><span>    </span><span>// 'plugin:vue/recommended' // Use this if you are using Vue.js 2.x.</span></span><span><span>  ],</span></span><span><span>}</span></span></code></pre><!--]--><!--]--></div><h3><a><!--[-->Rule 2. Use a component naming convention<!--]--></a></h3><p><!--[-->The bane of developers lives: how to name something.<!--]--></p><p><!--[-->You can address that by having an easy-to-follow convention on how to name a component. The convention also tells you where to put the component in your folder hierarchy.<!--]--></p><div><span>{prefix}</span>-<span>{namespace}</span><span>{?-class}</span></div><h4><a><!--[-->Prefix<!--]--></a></h4><blockquote><!--[--><p><!--[-->Base components (a.k.a. presentational, dumb, or pure components) that apply app-specific styling and conventions should all begin with a specific prefix, such as Base, App, or V.<!--]--></p><!--]--></blockquote><p><!--[-->A short prefix for <em><!--[-->all<!--]--></em> your components is preferable to the above.<!--]--></p><p><!--[-->Using a prefix avoids conflicts with HTML tags and third-party components. It also gives you scoped IDE autocompletion and more reusable components.<!--]--></p><p><!--[-->Prefixing becomes especially important when working with a component library (<a><!--[-->Vuetify<!--]--></a>, <a><!--[-->VueStrap<!--]--></a>, etc) or third-party components\n(<a><!--[-->algolia<!--]--></a>, <a><!--[-->google maps<!--]--></a>, etc).<!--]--></p><p><!--[-->You should use something which relates to your app, for example, I use <code><!--[-->h<!--]--></code> as the prefix because my site is harlanzw.com.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>&lt;</span><span>template</span><span>&gt;</span></span><span><span>  &lt;</span><span>p</span><span>&gt;</span><span>Please</span><span> </span><span>enter</span><span> </span><span>your</span><span> </span><span>email</span><span> </span><span>to</span><span> </span><span>subscribe</span><span>&lt;/</span><span>p</span><span>&gt;</span></span><span><span>  &lt;!-- </span><span>Vuetify</span><span> </span><span>components</span><span> </span><span>use</span><span> </span><span>a</span><span> </span><span>V</span><span> </span><span>prefix</span><span> --&gt;</span></span><span><span>  &lt;</span><span>v-text-field</span><span> </span><span>label</span><span>=</span><span>\"</span><span>Your Email</span><span>\"</span><span> /&gt;</span></span><span><span>  &lt;!-- </span><span>H</span><span> </span><span>is</span><span> </span><span>the</span><span> </span><span>prefix</span><span> </span><span>for</span><span> </span><span>my</span><span> </span><span>apps</span><span> </span><span>components</span><span> --&gt;</span></span><span><span>  &lt;</span><span>h-button</span><span>&gt;</span><span>Submit</span><span>&lt;/</span><span>h-button</span><span>&gt;</span></span><span><span>&lt;/</span><span>template</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><p><!--[-->You can use many prefixes for your components to help you with scoping code.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>&lt;</span><span>template</span><span>&gt;</span></span><span><span>  &lt;!-- </span><span>'</span><span>the</span><span>'</span><span> </span><span>as</span><span> </span><span>a</span><span> </span><span>prefix</span><span> </span><span>for</span><span> </span><span>layout</span><span> </span><span>components</span><span> --&gt;</span></span><span><span>  &lt;</span><span>the-header</span><span>&gt;</span></span><span><span>    &lt;!-- </span><span>'</span><span>v</span><span>'</span><span> </span><span>prefix</span><span> </span><span>for</span><span> </span><span>vuetify</span><span> </span><span>components</span><span> --&gt;</span></span><span><span>    &lt;</span><span>v-img</span><span> </span><span>src</span><span>=</span><span>\"</span><span>logo.png</span><span>\"</span><span> /&gt;</span></span><span><span>    &lt;!-- </span><span>'</span><span>h</span><span>'</span><span> </span><span>prefix</span><span> </span><span>for</span><span> </span><span>our</span><span> </span><span>branded</span><span> </span><span>components</span><span> --&gt;</span></span><span><span>    &lt;</span><span>h-button</span><span>&gt;</span><span>Sign</span><span> </span><span>In</span><span>&lt;/</span><span>h-button</span><span>&gt;</span></span><span><span>  &lt;/</span><span>the-header</span><span>&gt;</span></span><span><span>  &lt;</span><span>main</span><span>&gt;</span></span><span><span>    &lt;</span><span>the-sidebar</span><span> /&gt;</span></span><span><span>    &lt;</span><span>the-content</span><span> </span><span>v-html</span><span>=</span><span>\"</span><span>content</span><span>\"</span><span> /&gt;</span></span><span><span>  &lt;/</span><span>main</span><span>&gt;</span></span><span><span>  &lt;</span><span>the-footer</span><span> /&gt;</span></span><span><span>&lt;/</span><span>template</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><h4><a><!--[-->Namespace<!--]--></a></h4><blockquote><!--[--><p><!--[-->Child components that are tightly coupled with their parent should include the parent component name as a prefix.<!--]--></p><!--]--></blockquote><p><!--[-->The style guide recommends starting the component name with the parent component. I've found using a <em><!--[-->namespace<!--]--></em> after the prefix instead is more flexible.<!--]--></p><p><!--[-->Namespaces avoid conflicts, improve IDE autocompletion and define the scope of the component.<!--]--></p><p><!--[-->You should map namespaces to a folder, this way you can group components, making them easier to find and use.<!--]--></p><p><!--[-->An example of a namespace is <code><!--[-->Field<!--]--></code>, for all our field components (text field, textarea, search, etc.).<!--]--></p><div><!--[--><!--[--><pre><code><span><span>components/</span></span><span><span>|</span><span>- Field/ </span><span># namespace</span></span><span><span>|</span><span>--- HFieldText.vue</span></span><span><span>|</span><span>--- HFieldTextarea.vue</span></span><span><span>|</span><span>--- HFieldSearch.vue</span></span><span><span>|</span><span>--- HFieldAutocomplete.vue</span></span><span><span>|</span><span>--- HFieldCheckbox.vue</span></span></code></pre><!--]--><!--]--></div><p><!--[-->You can then create conventions that components in a namespace should follow. For example these components should all have a <code><!--[-->:value<!--]--></code> prop and <code><!--[-->$emit('input', value)<!--]--></code>.<!--]--></p><h4><a><!--[-->Class (optional)<!--]--></a></h4><blockquote><!--[--><p><!--[-->Component names should start with the highest-level (often most general) words and end with descriptive modifying words.<!--]--></p><!--]--></blockquote><p><!--[-->The final part of the convention is, in fact, the name of the component. Thinking of it as a class name makes the distinction between the namespace easier. You still want to follow the above style guide rule, our class names should be\ngeneral to descriptive.<!--]--></p><p><!--[-->The class should be optional. Namespaces can provide a default component to reduce the name of common components.<!--]--></p><p><!--[-->Imagine you have a project with a few buttons. Most of the time you want to use the default button, you shouldn't\nneed to name it <code><!--[-->HButtonDefault.vue<!--]--></code>.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>components/</span></span><span><span>|</span><span>- Button/ </span><span># namespace</span></span><span><span>|</span><span>--- HButton.vue </span><span># The namespaces default component </span></span><span><span>|</span><span>--- HButtonCallToAction.vue </span><span># A call to action button</span></span><span><span>|</span><span>--- HButtonSubmitForm.vue </span><span># A button to submit forms</span></span></code></pre><!--]--><!--]--></div><p><!--[-->Recommendations on naming the class:<!--]--></p><ul><!--[--><li><!--[-->Describe the application function of the component, rather than what it looks like.<ul><!--[--><li><!--[-->‚ùå <code><!--[-->HButtonRainbowFlashing.vue<!--]--></code><!--]--></li><li><!--[-->‚úÖ <code><!--[-->HButtonCallToAction.vue<!--]--></code><!--]--></li><!--]--></ul><!--]--></li><li><!--[-->Choose to be verbose if it adds clarity to the scope.<ul><!--[--><li><!--[-->‚ùå <code><!--[-->HProfileUser.vue<!--]--></code><!--]--></li><li><!--[-->‚úÖ <code><!--[-->HProfileAuthenticatedUsersCard.vue<!--]--></code><!--]--></li><!--]--></ul><!--]--></li><li><!--[-->Prefer full words over abbreviations. From the <a><!--[-->style guide<!--]--></a>.<!--]--></li><!--]--></ul><h3><a><!--[-->Rule 3. Separate component scopes<!--]--></a></h3><p><!--[-->Defining scopes for how components behave will guide you in staying DRY.<!--]--></p><p><!--[-->There are many ways to set this up. A good starting point is a scope for \"shared\" (a.k.a. base, presentational or dumb) components and \"app\" (a.k.a single-instance).<!--]--></p><div><!--[--><!--[--><pre><code><span><span>components/</span></span><span><span>|</span><span>- app </span><span># Contains application logic</span></span><span><span>|</span><span>- shared </span><span># Does not contain application logic</span></span></code></pre><!--]--><!--]--></div><p><!--[-->You could also pull out your \"shared\" components into their own npm package.<!--]--></p><p><!--[-->When creating new components it's natural to couple application logic in. With this setup, you'll think about component scopes more and how code can be re-used.<!--]--></p><figure><img><figcaption>A decision graph for component folders</figcaption></figure><h4><a><!--[-->\"Shared\" Folder - Base Components<!--]--></a></h4><p><!--[-->These components are re-usable and include form inputs, buttons, dialogues and modals. They should never contain application logic or state data.<!--]--></p><p><!--[-->You should be aiming to build your own \"UI kit\" from these components.<!--]--></p><p><!--[-->Copy-pasting your shared folder into a new project should work out of the box (assuming you handle dependencies).<!--]--></p><h4><a><!--[-->\"App\" Folder - App components<!--]--></a></h4><p><!--[-->App components do contain application logic and state data.<!--]--></p><p><!--[-->If you were to copy+paste an app component into a new project, it should not work.<!--]--></p><h2><a><!--[-->Example: Newsletter Sign Up<!--]--></a></h2><p><!--[-->This exists as two \"app\" components, they contain logic for validation and posting to an API. They both contain \"shared\" components.<!--]--></p><figure><img><figcaption>Newsletter component example</figcaption></figure><div><!--[--><!--[--><pre><code><span><span>components/</span></span><span><span># application component scope</span></span><span><span>|</span><span>- app/ </span></span><span><span>|</span><span>-- Newsletter </span><span># namespace</span></span><span><span>|</span><span>--- HNewsletterForm.vue </span><span># validates and posts data</span></span><span><span>|</span><span>--- HNewsletterCard.vue </span><span># handles successful form post</span></span><span><span># shared component scope</span></span><span><span>|</span><span>- shared/ </span></span><span><span>|</span><span>-- Alert/</span></span><span><span>|</span><span>--- HAlertSuccess.vue</span></span><span><span>|</span><span>-- Button/ </span></span><span><span>|</span><span>--- HButton.vue </span></span><span><span>|</span><span>-- Card/</span></span><span><span>|</span><span>--- HCard.vue</span></span><span><span>|</span><span>-- Form</span></span><span><span>|</span><span>--- HForm.vue</span></span><span><span>|</span><span>-- Field/</span></span><span><span>|</span><span>--- HFieldEmail.vue</span></span></code></pre><!--]--><!--]--></div><div><!--[--><span>HNewsletterForm.vue</span><!--[--><pre><code><span><span>&lt;</span><span>template</span><span>&gt;</span></span><span><span>  &lt;</span><span>h-form</span><span> </span><span>@</span><span>submit</span><span>=</span><span>\"</span><span>submit</span><span>\"</span><span>&gt;</span></span><span><span>    &lt;</span><span>h-field-email</span></span><span><span>      </span><span>v-model</span><span>=</span><span>\"</span><span>email</span><span>\"</span></span><span><span>      </span><span>label</span><span>=</span><span>\"</span><span>Enter your email</span><span>\"</span></span><span><span>    /&gt;</span></span><span><span>    &lt;</span><span>h-button</span><span> </span><span>type</span><span>=</span><span>\"</span><span>submit</span><span>\"</span><span>&gt;</span></span><span><span>      </span><span>Subscribe</span></span><span><span>    &lt;/</span><span>h-button</span><span>&gt;</span></span><span><span>  &lt;/</span><span>h-form</span><span>&gt;</span></span><span><span>&lt;/</span><span>template</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><div><!--[--><span>HNewsletterCard.vue</span><!--[--><pre><code><span><span>&lt;</span><span>template</span><span>&gt;</span></span><span><span>  &lt;</span><span>h-card</span><span>&gt;</span></span><span><span>    &lt;</span><span>div</span><span> </span><span>class</span><span>=</span><span>\"</span><span>pl-3</span><span>\"</span><span>&gt;</span></span><span><span>      &lt;</span><span>h</span><span>2&gt;</span><span>Keep</span><span> </span><span>up</span><span> </span><span>to</span><span> </span><span>date</span><span>&lt;/</span><span>h</span><span>2&gt;</span></span><span><span>      &lt;</span><span>h-newsletter-form</span></span><span><span>        </span><span>v-if</span><span>=</span><span>\"</span><span>!</span><span>success</span><span>\"</span></span><span><span>        </span><span>@</span><span>submit</span><span>=</span><span>\"</span><span>success </span><span>=</span><span> </span><span>true</span><span>\"</span></span><span><span>      /&gt;</span></span><span><span>      &lt;</span><span>h-alert-success</span></span><span><span>        </span><span>v-else</span></span><span><span>      &gt;</span></span><span><span>        </span><span>Thanks</span><span> </span><span>for</span><span> </span><span>signing</span><span> </span><span>up</span><span> :)</span></span><span><span>      &lt;/</span><span>h-alert-success</span><span>&gt;</span></span><span><span>    &lt;/</span><span>div</span><span>&gt;</span></span><span><span>  &lt;/</span><span>h-card</span><span>&gt;</span></span><span><span>&lt;/</span><span>template</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><h2><a><!--[-->Example: Forum Thread<!--]--></a></h2><p><!--[-->Now imagine you want to build a forum thread page. A user can see comments, upvote comments and post their own comment.<!--]--></p><figure><img><figcaption>Laravel.io Forum Thread</figcaption></figure><p><!--[-->Using <code><!--[-->F<!--]--></code> as our component prefix, let's look at what you need.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>components/</span></span><span><span># application component scope</span></span><span><span>|</span><span>- app/ </span></span><span><span>|</span><span>-- Thread </span><span># namespace</span></span><span><span>|</span><span>--- FThread.vue </span><span># Wraps the entire thread</span></span><span><span>|</span><span>--- FThreadPost.vue </span><span># A single post / reply</span></span><span><span>|</span><span>--- FThreadFormReply.vue </span><span># Form to submit a reply</span></span><span><span>|</span><span>-- Field/</span></span><span><span>|</span><span>--- FFieldComment.vue </span><span># Comment box for posts</span></span><span><span>|</span><span>-- Button/</span></span><span><span>|</span><span>--- FButtonUpvote.vue </span><span># The thumbs up button</span></span><span><span># shared component scope</span></span><span><span>|</span><span>- shared/ </span></span><span><span>|</span><span>-- Img/</span></span><span><span>|</span><span>--- FImgAvatar.vue </span><span># Users photos</span></span><span><span>|</span><span>-- Field/</span></span><span><span>|</span><span>--- FFieldWYSIWYG.vue </span><span># Comment box for posts</span></span><span><span>|</span><span>-- Card/</span></span><span><span>|</span><span>--- FCard.vue </span><span># Gives posts a 'card' look</span></span><span><span>|</span><span>-- Button/</span></span><span><span>|</span><span>--- FButton.vue </span><span># Reply button for the post box</span></span></code></pre><!--]--><!--]--></div><div><!--[--><span>FThread.vue</span><!--[--><pre><code><span><span>&lt;</span><span>template</span><span>&gt;</span></span><span><span>  &lt;</span><span>f-thread-post</span></span><span><span>    </span><span>v-for</span><span>=</span><span>\"</span><span>posts </span><span>as</span><span> </span><span>post</span><span>\"</span></span><span><span>    :key=</span><span>\"</span><span>post</span><span>.</span><span>id</span><span>\"</span></span><span><span>    :post=</span><span>\"</span><span>post</span><span>\"</span></span><span><span>  /</span><span>&gt;</span></span><span><span>  &lt;</span><span>f-thread-reply</span><span> </span><span>@submit=\"addPost\"</span><span> /&gt;</span></span><span><span>&lt;/</span><span>template</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><div><!--[--><span>FThreadPost.vue</span><!--[--><pre><code><span><span>&lt;</span><span>template</span><span>&gt;</span></span><span><span>  &lt;</span><span>f-card</span><span>&gt;</span></span><span><span>    &lt;</span><span>div</span><span> </span><span>class</span><span>=</span><span>\"</span><span>p-3 border-b-2 border-gray-500 flex</span><span>\"</span><span>&gt;</span></span><span><span>      &lt;</span><span>f-img-avatar</span><span> </span><span>:</span><span>src</span><span>=</span><span>\"</span><span>post.author.avatar</span><span>\"</span><span> /&gt;</span></span><span><span>      &lt;</span><span>span</span><span>&gt;{{ </span><span>post</span><span>.</span><span>author</span><span>.</span><span>name</span><span> }}&lt;/</span><span>span</span><span>&gt;</span></span><span><span>      &lt;</span><span>span</span><span>&gt;{{ </span><span>post</span><span>.</span><span>publishedAgo</span><span> }}&lt;/</span><span>span</span><span>&gt;</span></span><span><span>    &lt;/</span><span>div</span><span>&gt;</span></span><span><span>    &lt;</span><span>div</span><span> </span><span>class</span><span>=</span><span>\"</span><span>p-3 border-b-2 border-gray-500 prose</span><span>\"</span><span> </span><span>v-html</span><span>=</span><span>\"</span><span>post.content</span><span>\"</span><span> /&gt;</span></span><span><span>    &lt;</span><span>div</span><span> </span><span>class</span><span>=</span><span>\"</span><span>p-3</span><span>\"</span><span>&gt;</span></span><span><span>      &lt;</span><span>f-button-upvote</span></span><span><span>        </span><span>:</span><span>upvotes</span><span>=</span><span>\"</span><span>post.upvotes</span><span>\"</span></span><span><span>        </span><span>class</span><span>=</span><span>\"</span><span>border-r-2 border-gray-500 pr-3</span><span>\"</span></span><span><span>        </span><span>@</span><span>click</span><span>=</span><span>\"</span><span>upvote</span><span>\"</span></span><span><span>      /&gt;</span></span><span><span>    &lt;/</span><span>div</span><span>&gt;</span></span><span><span>  &lt;/</span><span>f-card</span><span>&gt;</span></span><span><span>&lt;/</span><span>template</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><div><!--[--><span>FThreadFormReply.vue</span><!--[--><pre><code><span><span>&lt;</span><span>template</span><span>&gt;</span></span><span><span>  &lt;</span><span>f-form</span><span> </span><span>@</span><span>submit</span><span>=</span><span>\"</span><span>submitComment</span><span>\"</span><span>&gt;</span></span><span><span>    &lt;</span><span>f-field-comment</span></span><span><span>      </span><span>label</span><span>=</span><span>\"</span><span>Write a reply</span><span>\"</span></span><span><span>    /&gt;</span></span><span><span>    &lt;</span><span>div</span><span> </span><span>class</span><span>=</span><span>\"</span><span>flex</span><span>\"</span><span>&gt;</span></span><span><span>      &lt;</span><span>p</span><span>&gt;</span><span>Please</span><span> </span><span>make</span><span> </span><span>sure</span><span> </span><span>you</span><span>'</span><span>ve read our Forum Rules before replying.&lt;/p&gt;</span></span><span><span>      &lt;f-button type=\"submit\"&gt;</span></span><span><span>        Reply</span></span><span><span>      &lt;/f-button&gt;</span></span><span><span>    &lt;/div&gt;</span></span><span><span>  &lt;/f-form&gt;</span></span><span><span>&lt;/template&gt;</span></span></code></pre><!--]--><!--]--></div><h2><a><!--[-->Extra and optional rules<!--]--></a></h2><h3><a><!--[-->Use An Automatic Component Importer<!--]--></a></h3><p><!--[-->Being tied to import paths once you have a few hundred components is going to slow you down.<!--]--></p><p><!--[-->Using an  <a><!--[-->automatic component imports<!--]--></a> will clean up your code. You'll be free to tinker with the directory structure of your components in any way you want.<!--]--></p><h3><a><!--[-->Typescript Components<!--]--></a></h3><p><!--[-->The value of types, when you're working with objects is too good to pass up. Will save you hours down the line in developer experience. As a starting point, I'd try and get your shared components using Typescript.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>&lt;</span><span>script</span><span> </span><span>lang</span><span>=</span><span>\"</span><span>ts</span><span>\"</span><span>&gt;</span></span><span><span>import</span><span> </span><span>type</span><span> { PropType } </span><span>from</span><span> </span><span>'</span><span>vue</span><span>'</span></span><span><span>import</span><span> { defineComponent } </span><span>from</span><span> </span><span>'</span><span>vue</span><span>'</span></span><span><span>import</span><span> </span><span>type</span><span> { Post } </span><span>from</span><span> </span><span>'</span><span>./types</span><span>'</span></span><span></span><span><span>export</span><span> </span><span>default</span><span> </span><span>defineComponent</span><span>({</span></span><span><span>  props</span><span>:</span><span> {</span></span><span><span>    post</span><span>:</span><span> {</span></span><span><span>      type</span><span>:</span><span> </span><span>Object</span><span> </span><span>as</span><span> </span><span>PropType</span><span>&lt;</span><span>Post</span><span>&gt;,</span></span><span><span>      required</span><span>:</span><span> </span><span>true</span></span><span><span>    }</span></span><span><span>  },</span></span><span><span>})</span></span><span><span>&lt;/</span><span>script</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><h3><a><!--[-->Components have \"one job\"<!--]--></a></h3><blockquote><!--[--><p><!--[-->Every component should have one job, any code in the component that isn't achieving that job shouldn't be there.<!--]--></p><!--]--></blockquote><p><!--[-->You should be thinking when you create a component what it's one core function is.<!--]--></p><p><!--[-->You can limit yourself with this mindset, but it's worth keeping in mind as you go.<!--]--></p><h3><a><!--[-->Create component demo pages<!--]--></a></h3><p><!--[-->Using a package like <a><!--[-->Storybook<!--]--></a> is a great idea, but it comes with overhead and when you're starting out it can be a bit overkill.<!--]--></p><p><!--[-->As a starting point, you can create pages under a <code><!--[-->/demo<!--]--></code> prefix and throw your components on it.\nYou want an easy way to find components and classes that are available.<!--]--></p><p><!--[-->Here is a rough demo page as an example: <a><!--[-->Massive Monster UI Demo<!--]--></a>. Keep it as basic as you want.<!--]--></p><figure><img><figcaption>Massive Monster Demo Page</figcaption></figure><h3><a><!--[-->Mixins and composables<!--]--></a></h3><p><!--[-->This one should be pretty obvious and there are enough articles elsewhere on using these.<!--]--></p><p><!--[-->You want to pull out common logic from components and put them in either mixins or composables.<!--]--></p><p><!--[-->Check out <a><!--[-->VueUse<!--]--></a> for some ideas on what that could look like.<!--]--></p><h2><a><!--[-->Thanks for reading<!--]--></a></h2><p><!--[-->If you like the technical side of Vue and Laravel, I'll be posting regular articles on this site. The best\nway to keep up to date is by following me <a><!--[-->@harlan_zw<!--]--></a> or signing up for the newsletter below.<!--]--></p></div><!--]-->",
            "url": "nuxt-blog-azure.vercel.app/blog/scale-your-vue-components",
            "title": "Scaling Your Vue Components for Mid-Large Size Apps",
            "summary": "Working on a mid-large size app usually means hundreds of components. How do you make sure these components will scale?",
            "image": "https://harlanzw.com/social/scale-your-vue-components.png",
            "date_modified": "2021-01-12T00:00:00.000Z",
            "author": {
                "name": "AnyBlog"
            }
        },
        {
            "id": "nuxt-blog-azure.vercel.app/blog/vue-automatic-component-imports",
            "content_html": "<div><p><!--[-->When first learning Vue, you are taught you need to import and add components to <code><!--[-->components<!--]--></code> in the script block.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>&lt;</span><span>script</span><span>&gt;</span></span><span><span>import</span><span> HelloWorld </span><span>from</span><span> </span><span>'</span><span>@/components/HelloWorld.vue</span><span>'</span></span><span><span>export</span><span> </span><span>default</span><span> {</span></span><span><span>  components</span><span>:</span><span> {</span></span><span><span>    HelloWorld</span></span><span><span>  }</span></span><span><span>}</span></span><span><span>&lt;/</span><span>script</span><span>&gt;</span></span><span></span><span><span>&lt;</span><span>template</span><span>&gt;</span></span><span><span>  &lt;</span><span>HelloWorld</span><span> /&gt;</span></span><span><span>&lt;/</span><span>template</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><p><!--[-->However, there's been a recent trend to \"upgrade\" the Vue developer experience (DX), having components magically import themselves\nat compile-time.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>&lt;</span><span>template</span><span>&gt;</span></span><span><span>  &lt;</span><span>HelloWorld</span><span> /&gt;</span></span><span><span>&lt;/</span><span>template</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><p><!--[-->In the wild, you can find auto component imports in most popular Vue frameworks, as part of the core or a plugin.<!--]--></p><ul><!--[--><li><!--[--><a><!--[-->Nuxt Components<!--]--></a><!--]--></li><li><!--[--><a><!--[-->Vuetify<!--]--></a><!--]--></li><li><!--[--><a><!--[-->Chakra<!--]--></a><!--]--></li><li><!--[--><a><!--[-->Vue CLI<!--]--></a> (built by me)<!--]--></li><li><!--[--><a><!--[-->Vite<!--]--></a><!--]--></li><!--]--></ul><p><!--[-->This article will look at: why automatic component imports exist, how you can easily build our own auto component importer using\na Webpack loader and what the performance cost of using them has on your app.<!--]--></p><p><!--[-->Finally, we'll look at some other compile-time DX upgrades that are possible.<!--]--></p><h2><a><!--[-->Why Automatic Component Imports?<!--]--></a></h2><p><!--[-->The <em><!--[-->why<!--]--></em> that comes first to my mind, is the developer experience is great. No more confusion or typos on import paths,\nrefactoring becomes easier and there's less code overall.<!--]--></p><p><!--[-->The unintuitive but equally great advantage is found in the problem that this feature first solved.<!--]--></p><p><!--[-->The UI framework <a><!--[-->Vuetify<!--]--></a> is a huge library of over 80 components, coming in at <a><!--[-->99.4KB<!--]--></a>\nfor their scripts. As far as I know, they were the first to introduce automatic component imports.<!--]--></p><h3><a><!--[-->Problem: UI Framework Bloat<!--]--></a></h3><p><!--[-->One of the complaints you'll hear about using a UI framework over something simple like <a><!--[-->TailwindCSS<!--]--></a>,\nis the bloat it will add to your app.<!--]--></p><p><!--[-->This is a valid concern. It's unlikely your application is going to need half the components that a UI framework has to offer. Forcing\nbrowsers to download code that will never run, dead code, is not ideal.<!--]--></p><p><!--[-->Additionally, this component bloat can make import paths harder to work with and further scope for issues to pop up.<!--]--></p><p><!--[-->So, how do Vuetify and other UI frameworks overcome their inherent bloat?<!--]--></p><h3><a><!--[-->Solution: webpack Optimisations<!--]--></a></h3><p><!--[-->As is the way, webpack is here to magically solve our problems with <a><!--[-->tree shaking<!--]--></a> and <a><!--[-->code splitting<!--]--></a> optimisations.<!--]--></p><p><!--[-->If tree shaking is new to you, you can think of it as an optimisation to remove code that isn't explicitly used. Banishing\n'dead' code to the shadow realm.<!--]--></p><p><!--[-->The tree shaking optimisation requires ES2015 module syntax, (i.e. <code><!--[-->import<!--]--></code> and <code><!--[-->export<!--]--></code>) and a production build. The code can't be compiled\nto CommonJS modules (i.e. <code><!--[-->require<!--]--></code>) for it to work.<!--]--></p><p><!--[-->So how does all this relate to automatic component imports?<!--]--></p><p><!--[-->With Vuetify handling the imports of your components (<em><!--[--><a><!--[-->√† la carte<!--]--></a><!--]--></em> as they call it), they\ncan ensure webpack optimisations are running out of the box for your app with their component library.<!--]--></p><blockquote><!--[--><p><!--[-->The A la carte system enables you to pick and choose which components to import, drastically lowering your build size.<!--]--></p><!--]--></blockquote><blockquote><!--[--><p><!--[-->This will also make code-splitting more effective, as webpack will only load the components required for that chunk to be displayed.<!--]--></p><!--]--></blockquote><h2><a><!--[-->Fundamental: How Does webpack Load Vue Files?<!--]--></a></h2><p><!--[-->Before we jump into building our own automatic component importer, we'll need to have a basic understanding of how webpack loads Vue files.<!--]--></p><p><!--[-->When you request a resource (such as a file) in webpack, it pushes the request through a pipeline of webpack loaders to resolve the output. A webpack loader is a piece of code which will transform a resource from one thing into another, it has an <code><!--[-->input<!--]--></code> and <code><!--[-->output<!--]--></code>.<!--]--></p><p><!--[-->For example, the <a><!--[-->raw-loader<!--]--></a> will read a file and give you the string contents.\nThe <code><!--[-->input<!--]--></code> is a path to a file in your filesystem, the <code><!--[-->output<!--]--></code> is the string contents of the file.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>import</span><span> txt </span><span>from</span><span> </span><span>'</span><span>raw-loader!./hello.txt</span><span>'</span></span><span><span>// txt=HelloWorld</span></span></code></pre><!--]--><!--]--></div><p><!--[-->The <code><!--[-->vue-loader<!--]--></code> is the loader for <code><!--[-->.vue<!--]--></code> files. The loader compiles and bundles your component Single File Component (SFC) into code\nthat the browser can understand and run.<!--]--></p><h3><a><!--[-->Vue Loader in Action<!--]--></a></h3><p><!--[-->Let's take a look at an example of input and output from the vue-loader.<!--]--></p><h4><a><!--[-->Input: App.vue<!--]--></a></h4><p><!--[-->This is the default entry file for Vue CLI with Vue 3.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>&lt;</span><span>script</span><span>&gt;</span></span><span><span>import</span><span> HelloWorld </span><span>from</span><span> </span><span>'</span><span>./components/HelloWorld.vue</span><span>'</span></span><span></span><span><span>export</span><span> </span><span>default</span><span> {</span></span><span><span>  name</span><span>:</span><span> </span><span>'</span><span>App</span><span>'</span><span>,</span></span><span><span>  components</span><span>:</span><span> {</span></span><span><span>    HelloWorld</span></span><span><span>  }</span></span><span><span>}</span></span><span><span>&lt;/</span><span>script</span><span>&gt;</span></span><span></span><span><span>&lt;</span><span>template</span><span>&gt;</span></span><span><span>  &lt;</span><span>img</span><span> </span><span>alt</span><span>=</span><span>\"</span><span>Vue logo</span><span>\"</span><span> </span><span>src</span><span>=</span><span>\"</span><span>./assets/logo.png</span><span>\"</span><span>&gt;</span></span><span><span>  &lt;</span><span>HelloWorld</span><span> </span><span>msg</span><span>=</span><span>\"</span><span>Welcome to Your Vue.js App</span><span>\"</span><span> /&gt;</span></span><span><span>&lt;/</span><span>template</span><span>&gt;</span></span><span></span><span><span>&lt;</span><span>style</span><span>&gt;</span></span><span><span>#app</span><span> {</span></span><span><span>  </span><span>font-family</span><span>:</span><span> Avenir, </span><span>Helvetica</span><span>, </span><span>Arial</span><span>, </span><span>sans-serif</span><span>;</span></span><span><span>  </span><span>-webkit-font-smoothing</span><span>:</span><span> </span><span>antialiased</span><span>;</span></span><span><span>  </span><span>-moz-osx-font-smoothing</span><span>:</span><span> </span><span>grayscale</span><span>;</span></span><span><span>  </span><span>text-align</span><span>:</span><span> </span><span>center</span><span>;</span></span><span><span>  </span><span>color</span><span>:</span><span> </span><span>#2c3e50</span><span>;</span></span><span><span>  </span><span>margin-top</span><span>:</span><span> </span><span>60</span><span>px</span><span>;</span></span><span><span>}</span></span><span><span>&lt;/</span><span>style</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><h4><a><!--[-->Output: App.vue<!--]--></a></h4><p><!--[-->Internally, the loader parses this code using the compiler, getting an SFC descriptor object that is used to create the\nfinal string output of the loader.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>import</span><span> { render } </span><span>from</span><span> </span><span>'</span><span>./App.vue?vue&amp;type=template&amp;id=7ba5bd90</span><span>'</span></span><span><span>import</span><span> script </span><span>from</span><span> </span><span>'</span><span>./App.vue?vue&amp;type=script&amp;lang=js</span><span>'</span></span><span></span><span><span>import</span><span> </span><span>'</span><span>./App.vue?vue&amp;type=style&amp;index=0&amp;id=7ba5bd90&amp;lang=css</span><span>'</span></span><span><span>export</span><span> </span><span>*</span><span> </span><span>from</span><span> </span><span>'</span><span>./App.vue?vue&amp;type=script&amp;lang=js</span><span>'</span></span><span><span>script.render </span><span>=</span><span> render</span></span><span><span>script.__file </span><span>=</span><span> </span><span>'</span><span>src/App.vue</span><span>'</span></span><span></span><span><span>export</span><span> </span><span>default</span><span> script</span></span></code></pre><!--]--><!--]--></div><p><!--[-->Note: I've removed the Hot Module Reloading (HMR) code for simplicity here.<!--]--></p><p><!--[-->The output of the loader isn't that important to understand, just know that the vue-loader has an in and out function. The output\nis usually parsed to another loader such as <a><!--[-->babel-loader<!--]--></a> before being chunked.<!--]--></p><h2><a><!--[-->Building an Automatic Component Importer<!--]--></a></h2><p><!--[-->If you have some spare time, I'd encourage you to join along. You can use <a><!--[-->Vue CLI<!--]--></a> with the Vue 3 preset.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>vue create auto-component-importer -p __default_vue_3__</span></span></code></pre><!--]--><!--]--></div><p><!--[-->To begin, let's remove the manual import from the entry SFC, like so:<!--]--></p><h3><a><!--[-->New App.vue<!--]--></a></h3><div><!--[--><span>App.vue</span><!--[--><pre><code><span><span>&lt;</span><span>script</span><span>&gt;</span></span><span><span>export</span><span> </span><span>default</span><span> {</span></span><span><span>  name</span><span>:</span><span> </span><span>'</span><span>App</span><span>'</span><span>,</span></span><span><span>}</span></span><span><span>&lt;/</span><span>script</span><span>&gt;</span></span><span></span><span><span>&lt;</span><span>template</span><span>&gt;</span></span><span><span>  &lt;</span><span>img</span><span> </span><span>alt</span><span>=</span><span>\"</span><span>Vue logo</span><span>\"</span><span> </span><span>src</span><span>=</span><span>\"</span><span>./assets/logo.png</span><span>\"</span><span>&gt;</span></span><span><span>  &lt;</span><span>HelloWorld</span><span> </span><span>msg</span><span>=</span><span>\"</span><span>Welcome to Your Vue.js App</span><span>\"</span><span> /&gt;</span></span><span><span>&lt;/</span><span>template</span><span>&gt;</span></span><span></span><span><span>&lt;</span><span>style</span><span>&gt;</span></span><span><span>#app</span><span> {</span></span><span><span>  </span><span>font-family</span><span>:</span><span> Avenir, </span><span>Helvetica</span><span>, </span><span>Arial</span><span>, </span><span>sans-serif</span><span>;</span></span><span><span>  </span><span>-webkit-font-smoothing</span><span>:</span><span> </span><span>antialiased</span><span>;</span></span><span><span>  </span><span>-moz-osx-font-smoothing</span><span>:</span><span> </span><span>grayscale</span><span>;</span></span><span><span>  </span><span>text-align</span><span>:</span><span> </span><span>center</span><span>;</span></span><span><span>  </span><span>color</span><span>:</span><span> </span><span>#2c3e50</span><span>;</span></span><span><span>  </span><span>margin-top</span><span>:</span><span> </span><span>60</span><span>px</span><span>;</span></span><span><span>}</span></span><span><span>&lt;/</span><span>style</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><p><!--[-->When we load our <code><!--[-->App.vue<!--]--></code>, the <code><!--[-->HelloWorld<!--]--></code> doesn't work, as expected. Our goal is to get it to work without touching the Vue code.<!--]--></p><h3><a><!--[-->Step 1. Modify the webpack Configuration<!--]--></a></h3><p><!--[-->We need to make sure the loader we'll be making is going to run after the vue-loader.<!--]--></p><div><!--[--><span>./vue.config.js</span><!--[--><pre><code><span><span>module</span><span>.</span><span>exports</span><span> </span><span>=</span><span> {</span></span><span><span>  </span><span>chainWebpack</span><span>:</span><span> (</span><span>config</span><span>) </span><span>=&gt;</span><span> {</span></span><span><span>    config.module</span></span><span><span>      .rules</span></span><span><span>      .</span><span>get</span><span>(</span><span>'</span><span>vue</span><span>'</span><span>)</span></span><span><span>      .</span><span>use</span><span>(</span><span>'</span><span>components</span><span>'</span><span>)</span></span><span><span>      .</span><span>loader</span><span>(require.</span><span>resolve</span><span>(</span><span>'</span><span>./imports-loader</span><span>'</span><span>))</span></span><span><span>      .</span><span>before</span><span>(</span><span>'</span><span>vue-loader</span><span>'</span><span>)</span></span><span><span>      .</span><span>end</span><span>()</span></span><span><span>  }</span></span><span><span>}</span></span></code></pre><!--]--><!--]--></div><p><!--[-->If you'd like to see the raw webpack config example, open the below.<!--]--></p><details>\n  <summary>webpack.config.js example</summary><div><!--[--><span>webpack.config.js</span><!--[--><pre><code><span><span>module</span><span>.</span><span>exports</span><span> </span><span>=</span><span> {</span></span><span><span>  </span><span>// ...</span></span><span><span>  module</span><span>:</span><span> {</span></span><span><span>    rules</span><span>:</span><span> [</span></span><span><span>      {</span></span><span><span>        test</span><span>:</span><span> </span><span>/</span><span>\\.vue</span><span>$</span><span>/</span><span>,</span></span><span><span>        loader</span><span>:</span><span> </span><span>'</span><span>vue-loader</span><span>'</span></span><span><span>      }</span></span><span><span>    ]</span></span><span><span>  }</span></span><span><span>}</span></span></code></pre><!--]--><!--]--></div><p><!--[-->Knowing that webpack loaders are loaded from bottom to top, we would modify the configuration as so:<!--]--></p><div><!--[--><span>webpack.config.js</span><!--[--><pre><code><span><span>module</span><span>.</span><span>exports</span><span> </span><span>=</span><span> {</span></span><span><span>  </span><span>// ...</span></span><span><span>  module</span><span>:</span><span> {</span></span><span><span>    rules</span><span>:</span><span> [</span></span><span><span>      {</span></span><span><span>        test</span><span>:</span><span> </span><span>/</span><span>\\.vue</span><span>$</span><span>/</span><span>,</span></span><span><span>        use</span><span>:</span><span> [</span></span><span><span>          {</span></span><span><span>            loader</span><span>:</span><span> require.</span><span>resolve</span><span>(</span><span>'</span><span>./imports-loader</span><span>'</span><span>),</span></span><span><span>          },</span></span><span><span>          {</span></span><span><span>            loader</span><span>:</span><span> </span><span>'</span><span>vue-loader</span><span>'</span><span>,</span></span><span><span>          }</span></span><span><span>        ]</span></span><span><span>      },</span></span><span><span>    ]</span></span><span><span>  }</span></span><span><span>}</span></span></code></pre><!--]--><!--]--></div><div><div><div><svg><path><animate></animate></path><rect><animate></animate></rect></svg></div><div><!--[-->Normally a webpack would handle this configuration changing for you.<!--]--></div></div></div></details><p><!--[-->Now we create the loader called <code><!--[-->imports-loader.js<!--]--></code> in your apps root directory. We're going to make sure we only run it for the virtual SFC module.<!--]--></p><div><!--[--><span>imports-loader.js</span><!--[--><pre><code><span><span>module</span><span>.</span><span>exports</span><span> </span><span>=</span><span> </span><span>function</span><span> </span><span>loader</span><span>(</span><span>source</span><span>) {</span></span><span><span>  </span><span>// only run for the virtual SFC</span></span><span><span>  </span><span>if</span><span> (</span><span>this</span><span>.resourceQuery)</span></span><span><span>    </span><span>return</span><span> source</span></span><span></span><span><span>  console.</span><span>log</span><span>(source)</span></span><span><span>  </span><span>return</span><span> source</span></span><span><span>}</span></span></code></pre><!--]--><!--]--></div><p><!--[-->The <code><!--[-->source<!--]--></code> variable is the output of the vue-loader, the <a><!--[-->Output: App.vue<!--]--></a>.<!--]--></p><p><!--[-->Here we can now change anything about how our components work by modifying the vue-loader output.<!--]--></p><h3><a><!--[-->Step 2. Dumb Compile-Time Import<!--]--></a></h3><p><!--[-->As a proof of concept, let's try to import the <code><!--[-->HelloWorld.vue<!--]--></code> component so our <a><!--[-->New App.vue<!--]--></a> works.<!--]--></p><p><!--[-->At this stage, we can just append the import code on to the <code><!--[-->source<!--]--></code>.<!--]--></p><div><!--[--><span>imports-loader.js</span><!--[--><pre><code><span><span>module</span><span>.</span><span>exports</span><span> </span><span>=</span><span> </span><span>function</span><span> </span><span>loader</span><span>(</span><span>source</span><span>) {</span></span><span><span>  </span><span>// only run for the virtual SFC</span></span><span><span>  </span><span>if</span><span> (</span><span>this</span><span>.resourceQuery)</span></span><span><span>    </span><span>return</span><span> source</span></span><span></span><span><span>  </span><span>return</span><span> </span><span>`</span><span>${</span><span>source</span><span>}</span></span><span><span>import HelloWorld from \"@/components/HelloWorld.vue\"</span></span><span><span>script.components = Object.assign({ HelloWorld }, script.components)</span></span><span><span>`</span></span><span><span>}</span></span></code></pre><!--]--><!--]--></div><p><!--[-->Your <code><!--[-->App.vue<!--]--></code> now knows what the HelloWorld component is and works. Try it yourself.<!--]--></p><p><!--[-->Note: This is a <em><!--[-->dumb<!--]--></em> solution, as it will be modifying <code><!--[-->HelloWorld.vue<!--]--></code> to also import itself.<!--]--></p><h3><a><!--[-->Step 3. Making it smart<!--]--></a></h3><p><!--[-->A smarter solution would give us the ability to add components to our component folder and use them straight away without\nany imports.<!--]--></p><h4><a><!--[-->a. Scan components<!--]--></a></h4><p><!--[-->The first step in making it smarter is we need to create a map of the components files we want to automatically import.<!--]--></p><p><!--[-->We recursively iterate over the components folder and do some mapping.<!--]--></p><div><!--[--><span>a. Scan components</span><!--[--><pre><code><span><span>const</span><span> base </span><span>=</span><span> </span><span>'</span><span>./src/components/</span><span>'</span></span><span><span>const</span><span> fileComponents </span><span>=</span><span> (</span><span>await</span><span> </span><span>globby</span><span>(</span><span>'</span><span>*.vue</span><span>'</span><span>, { cwd</span><span>:</span><span> base })).</span><span>map</span><span>((</span><span>c</span><span>) </span><span>=&gt;</span><span> {</span></span><span><span>  </span><span>const</span><span> name </span><span>=</span><span> path.</span><span>parse</span><span>(c).name</span></span><span><span>  </span><span>const</span><span> shortPath </span><span>=</span><span> path.</span><span>resolve</span><span>(base).</span><span>replace</span><span>(path.</span><span>resolve</span><span>(</span><span>'</span><span>./src</span><span>'</span><span>), </span><span>'</span><span>@</span><span>'</span><span>)</span></span><span><span>  </span><span>return</span><span> {</span></span><span><span>    name,</span></span><span><span>    import</span><span>:</span><span> </span><span>`import </span><span>${</span><span>name</span><span>}</span><span> from \"</span><span>${</span><span>shortPath</span><span>}</span><span>/</span><span>${</span><span>c</span><span>}</span><span>\"`</span></span><span><span>  }</span></span><span><span>})</span></span><span><span>// [ { name: 'HelloWorld', import: 'import HelloWorld from \"@/components/HelloWorld.vue\"' } ]</span></span></code></pre><!--]--><!--]--></div><h4><a><!--[-->b. Find the template tags<!--]--></a></h4><p><!--[-->To understand what components are being used, we need to have our new loader to compile the SFC <code><!--[-->&lt;template&gt;<!--]--></code> blocks.<!--]--></p><div><!--[--><span>b. Find the template tags</span><!--[--><pre><code><span><span>const</span><span> compiler </span><span>=</span><span> </span><span>require</span><span>(</span><span>'</span><span>@vue/compiler-sfc</span><span>'</span><span>)</span></span><span><span>const</span><span> parsed </span><span>=</span><span> compiler.</span><span>parse</span><span>(fs.</span><span>readFileSync</span><span>(</span><span>`</span><span>${</span><span>this</span><span>.context</span><span>}</span><span>/</span><span>${</span><span>path.</span><span>basename</span><span>(</span><span>this</span><span>.resourcePath)</span><span>}</span><span>`</span><span>, </span><span>'</span><span>utf8</span><span>'</span><span>)).descriptor</span></span><span><span>const</span><span> template </span><span>=</span><span> compiler.</span><span>compileTemplate</span><span>({</span></span><span><span>  id</span><span>:</span><span> </span><span>'</span><span>tmp</span><span>'</span><span>,</span></span><span><span>  source</span><span>:</span><span> parsed.template.content,</span></span><span><span>  filename</span><span>:</span><span> </span><span>this</span><span>.resourcePath,</span></span><span><span>})</span></span><span><span>const</span><span> componentTags </span><span>=</span><span> template.ast.components</span></span><span><span>// [ 'HelloWorld' ]</span></span></code></pre><!--]--><!--]--></div><p><!--[-->Note: For simplicity, we're using Vue 3's compiler. The above won't work for Vue 2.<!--]--></p><h4><a><!--[-->c. Matchmaking<!--]--></a></h4><p><!--[-->With our freshly compiled template, we need to match the components we found in our template with the mapped component files\nfrom <a><!--[-->a. Scan Components<!--]--></a>.<!--]--></p><div><!--[--><span>c. Match making</span><!--[--><pre><code><span><span>const</span><span> matches </span><span>=</span><span> []</span></span><span><span>componentTags.</span><span>forEach</span><span>(</span><span>tag</span><span> </span><span>=&gt;</span><span> matches.</span><span>push</span><span>(</span><span>first</span><span>(</span><span>filter</span><span>(fileComponents, </span><span>c</span><span> </span><span>=&gt;</span><span> c.name </span><span>===</span><span> tag))))</span></span><span><span>// [ { name: 'HelloWorld', import: 'import HelloWorld from \"@/components/HelloWorld.vue\"' } ]</span></span></code></pre><!--]--><!--]--></div><p><!--[-->If you wanted to match non-PascalCase names, you would modify this matcher function.<!--]--></p><h4><a><!--[-->d. Insert the new dynamic imports<!--]--></a></h4><p><!--[-->The final piece of the puzzle is appending the list of matched components and inserting the import line and assigning\nthe components.<!--]--></p><div><!--[--><span>d. Insert the new dynamic imports</span><!--[--><pre><code><span><span>if</span><span> (</span><span>!</span><span>matches.length)</span></span><span><span>  </span><span>return</span><span> source</span></span><span></span><span><span>const</span><span> newContent </span><span>=</span><span> </span><span>`</span></span><span><span>${</span><span>matches.</span><span>map</span><span>(</span><span>c</span><span> </span><span>=&gt;</span><span> </span><span>c.import).</span><span>join</span><span>(</span><span>'</span><span>\\n</span><span>'</span><span>)</span><span>}</span></span><span><span>script.components = Object.assign({ </span><span>${</span><span>matches.</span><span>map</span><span>(</span><span>c</span><span> </span><span>=&gt;</span><span> </span><span>c.name).</span><span>join</span><span>(</span><span>'</span><span>, </span><span>'</span><span>)</span><span>}</span><span> }, script.components);</span></span><span><span>`</span></span><span><span>const</span><span> hotReload </span><span>=</span><span> source.</span><span>indexOf</span><span>(</span><span>'</span><span>/* hot reload */</span><span>'</span><span>)</span></span><span><span>if</span><span> (hotReload </span><span>&gt;</span><span> </span><span>-</span><span>1</span><span>)</span></span><span><span>  source </span><span>=</span><span> </span><span>`</span><span>${</span><span>source.</span><span>slice</span><span>(</span><span>0</span><span>, </span><span>hotReload)</span><span> </span><span>+</span><span> </span><span>newContent</span><span>}\\n\\n${</span><span>source.</span><span>slice</span><span>(hotReload)</span><span>}</span><span>`</span></span><span><span>else</span></span><span><span>  source </span><span>+=</span><span> </span><span>`</span><span>\\n\\n${</span><span>newContent</span><span>}</span><span>`</span></span><span></span><span><span>return</span><span> source</span></span></code></pre><!--]--><!--]--></div><p><!--[-->We need to insert the new content before the HMR code if available, otherwise we need to restart our app to find\nnew components.<!--]--></p><h3><a><!--[-->Putting it all together<!--]--></a></h3><p><!--[-->Below is the full <code><!--[-->imports-loader.js<!--]--></code> for reference. This loader should <em><!--[-->just work<!--]--></em>. Create\na new component and then use it straight away, make sure you use PascalCase.<!--]--></p><div><!--[--><span>imports-loader.js</span><!--[--><pre><code><span><span>const</span><span> fs </span><span>=</span><span> </span><span>require</span><span>(</span><span>'</span><span>fs</span><span>'</span><span>)</span></span><span><span>const</span><span> path </span><span>=</span><span> </span><span>require</span><span>(</span><span>'</span><span>path</span><span>'</span><span>)</span></span><span><span>const</span><span> globby </span><span>=</span><span> </span><span>require</span><span>(</span><span>'</span><span>globby</span><span>'</span><span>)</span></span><span><span>const</span><span> first </span><span>=</span><span> </span><span>require</span><span>(</span><span>'</span><span>lodash/first</span><span>'</span><span>)</span></span><span><span>const</span><span> filter </span><span>=</span><span> </span><span>require</span><span>(</span><span>'</span><span>lodash/filter</span><span>'</span><span>)</span></span><span></span><span><span>module</span><span>.</span><span>exports</span><span> </span><span>=</span><span> </span><span>async</span><span> </span><span>function</span><span> </span><span>loader</span><span>(</span><span>source</span><span>) {</span></span><span><span>  </span><span>// only run for the non-query requests</span></span><span><span>  </span><span>if</span><span> (</span><span>this</span><span>.resourceQuery)</span></span><span><span>    </span><span>return</span><span> source</span></span><span></span><span><span>  </span><span>// a. Scan components</span></span><span><span>  </span><span>const</span><span> base </span><span>=</span><span> </span><span>'</span><span>./src/components/</span><span>'</span></span><span><span>  </span><span>const</span><span> fileComponents </span><span>=</span><span> (</span><span>await</span><span> </span><span>globby</span><span>(</span><span>'</span><span>*.vue</span><span>'</span><span>, { cwd</span><span>:</span><span> base })).</span><span>map</span><span>((</span><span>c</span><span>) </span><span>=&gt;</span><span> {</span></span><span><span>    </span><span>const</span><span> name </span><span>=</span><span> path.</span><span>parse</span><span>(c).name</span></span><span><span>    </span><span>const</span><span> shortPath </span><span>=</span><span> path.</span><span>resolve</span><span>(base).</span><span>replace</span><span>(path.</span><span>resolve</span><span>(</span><span>'</span><span>./src</span><span>'</span><span>), </span><span>'</span><span>@</span><span>'</span><span>)</span></span><span><span>    </span><span>return</span><span> {</span></span><span><span>      name,</span></span><span><span>      import</span><span>:</span><span> </span><span>`import </span><span>${</span><span>name</span><span>}</span><span> from \"</span><span>${</span><span>shortPath</span><span>}</span><span>/</span><span>${</span><span>c</span><span>}</span><span>\"`</span></span><span><span>    }</span></span><span><span>  })</span></span><span></span><span><span>  </span><span>// b. Find the template tags</span></span><span><span>  </span><span>const</span><span> compiler </span><span>=</span><span> </span><span>require</span><span>(</span><span>'</span><span>@vue/compiler-sfc</span><span>'</span><span>)</span></span><span><span>  </span><span>const</span><span> parsed </span><span>=</span><span> compiler.</span><span>parse</span><span>(fs.</span><span>readFileSync</span><span>(</span><span>`</span><span>${</span><span>this</span><span>.context</span><span>}</span><span>/</span><span>${</span><span>path.</span><span>basename</span><span>(</span><span>this</span><span>.resourcePath)</span><span>}</span><span>`</span><span>, </span><span>'</span><span>utf8</span><span>'</span><span>)).descriptor</span></span><span><span>  </span><span>const</span><span> template </span><span>=</span><span> compiler.</span><span>compileTemplate</span><span>({</span></span><span><span>    id</span><span>:</span><span> </span><span>'</span><span>na</span><span>'</span><span>,</span></span><span><span>    source</span><span>:</span><span> parsed.template.content,</span></span><span><span>    filename</span><span>:</span><span> </span><span>this</span><span>.resourcePath,</span></span><span><span>  })</span></span><span><span>  </span><span>const</span><span> componentTags </span><span>=</span><span> template.ast.components</span></span><span></span><span><span>  </span><span>// c. Match making</span></span><span><span>  </span><span>const</span><span> matches </span><span>=</span><span> []</span></span><span><span>  componentTags.</span><span>forEach</span><span>(</span><span>tag</span><span> </span><span>=&gt;</span><span> matches.</span><span>push</span><span>(</span><span>first</span><span>(</span><span>filter</span><span>(fileComponents, </span><span>c</span><span> </span><span>=&gt;</span><span> c.name </span><span>===</span><span> tag))))</span></span><span></span><span><span>  </span><span>// d. Insert the new dynamic imports</span></span><span><span>  </span><span>if</span><span> (</span><span>!</span><span>matches.length)</span></span><span><span>    </span><span>return</span><span> source</span></span><span></span><span><span>  </span><span>const</span><span> newContent </span><span>=</span><span> </span><span>`</span></span><span><span>${</span><span>matches.</span><span>map</span><span>(</span><span>c</span><span> </span><span>=&gt;</span><span> </span><span>c.import).</span><span>join</span><span>(</span><span>'</span><span>\\n</span><span>'</span><span>)</span><span>}</span></span><span><span>script.components = Object.assign({ </span><span>${</span><span>matches.</span><span>map</span><span>(</span><span>c</span><span> </span><span>=&gt;</span><span> </span><span>c.name).</span><span>join</span><span>(</span><span>'</span><span>, </span><span>'</span><span>)</span><span>}</span><span> }, script.components);</span></span><span><span>`</span></span><span><span>  </span><span>const</span><span> hotReload </span><span>=</span><span> source.</span><span>indexOf</span><span>(</span><span>'</span><span>/* hot reload */</span><span>'</span><span>)</span></span><span><span>  </span><span>if</span><span> (hotReload </span><span>&gt;</span><span> </span><span>-</span><span>1</span><span>)</span></span><span><span>    source </span><span>=</span><span> </span><span>`</span><span>${</span><span>source.</span><span>slice</span><span>(</span><span>0</span><span>, </span><span>hotReload)</span><span> </span><span>+</span><span> </span><span>newContent</span><span>}\\n\\n${</span><span>source.</span><span>slice</span><span>(hotReload)</span><span>}</span><span>`</span></span><span><span>  </span><span>else</span></span><span><span>    source </span><span>+=</span><span> </span><span>`</span><span>\\n\\n${</span><span>newContent</span><span>}</span><span>`</span></span><span></span><span><span>  </span><span>return</span><span> source</span></span><span><span>}</span></span></code></pre><!--]--><!--]--></div><div><div><div><svg><path><animate></animate></path><rect><animate></animate></rect></svg></div><div><!--[-->There are several issues and edge cases with the above code, this is merely a proof of concept and shouldn't be used in\nproduction.If you're after a more complete solution you should clone the repos listed before.<!--]--></div></div></div><h2><a><!--[-->Problems With Automatic Component Imports<!--]--></a></h2><p><!--[-->Hopefully, you now have a better understanding of how auto component importing works. While working through that rough proof of\nconcept, you may have foreseen some issues.<!--]--></p><h3><a><!--[-->Performance Cost<!--]--></a></h3><p><!--[-->For automatic component imports to provide their magic, they need to parse the SFC and compile the template at compile time. If you recall,\nwe are running our loader after the <code><!--[-->vue-loader<!--]--></code>, that means this compilation has already been completed and is happening again.<!--]--></p><p><!--[-->This means that by using this feature, we are potentially <strong><!--[-->doubling our component build time<!--]--></strong>. Which affects the hot module\nreplacement speed, the web-dev-server boot-time and the production build time.<!--]--></p><p><!--[-->Saying that certain optimisations can and are made. Loader output can be cached with one line, so unless we change a file\nwe don't need to recompile it.<!--]--></p><div><!--[--><span>imports-loaders.js</span><!--[--><pre><code><span><span>// ...</span></span><span><span>module</span><span>.</span><span>exports</span><span> </span><span>=</span><span> </span><span>async</span><span> </span><span>function</span><span> </span><span>loader</span><span>(</span><span>source</span><span>) {</span></span><span><span>  </span><span>this</span><span>.</span><span>cache</span><span>()</span></span><span><span>  </span><span>// ...</span></span><span><span>}</span></span></code></pre><!--]--><!--]--></div><p><!--[-->For Vue 3 there may be a new way to optimise this feature. I've based the proof of concept on how the existing Vue 2 plugins work.<!--]--></p><h3><a><!--[-->Static code only<!--]--></a></h3><p><!--[-->If you have a dynamic import then it's not going to work. I don't think this is a massive issue as you can\nwork around it with manual imports or using the <code><!--[-->v-if<!--]--></code> on inline components. Consider the below\ncode:<!--]--></p><div><!--[--><!--[--><pre><code><span><span>&lt;</span><span>script</span><span>&gt;</span></span><span><span>export</span><span> </span><span>default</span><span> {</span></span><span><span>  computed</span><span>:</span><span> {</span></span><span><span>    </span><span>myComponent</span><span>() {</span></span><span><span>      </span><span>return</span><span> </span><span>Math</span><span>.</span><span>random</span><span>() </span><span>*</span><span> </span><span>100</span><span> </span><span>&gt;</span><span> </span><span>50</span><span> </span><span>?</span><span> ComponentA </span><span>:</span><span> ComponentB</span></span><span><span>    }</span></span><span><span>  }</span></span><span><span>}</span></span><span><span>&lt;/</span><span>script</span><span>&gt;</span></span><span></span><span><span>&lt;</span><span>template</span><span>&gt;</span></span><span><span>  &lt;</span><span>component</span><span> </span><span>:</span><span>is</span><span>=</span><span>\"</span><span>myComponent</span><span>\"</span><span> /&gt;</span></span><span><span>&lt;/</span><span>template</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><p><!--[-->For now, the automatic import of <code><!--[-->ComponentA<!--]--></code> and <code><!--[-->ComponentB<!--]--></code> is not possible.<!--]--></p><h3><a><!--[-->Stricter component naming<!--]--></a></h3><p><!--[-->Due to the nature of mapping a file name to a component name, it sets a few requirements around how you name your components.\nIf you're following the Vue <a><!--[-->style-guide<!--]--></a> for component naming, you shouldn't have an issue.<!--]--></p><p><!--[-->If you're going to adopt automatic component imports I'd recommend the following rules:<!--]--></p><ul><!--[--><li><!--[-->Namespace all components (i.e <code><!--[-->HButtonOutline<!--]--></code>, <code><!--[-->H<!--]--></code> is the namespace)<!--]--></li><li><!--[-->Avoid non-unique component file names<!--]--></li><li><!--[-->Use nested folders to separate scopes<!--]--></li><!--]--></ul><h2><a><!--[-->Other Compile-Time \"Upgrades\"<!--]--></a></h2><h3><a><!--[-->Import Directive Support<!--]--></a></h3><p><!--[-->When compiling the template, we can also see when specific directives are used.\nIf the directive is not globally registered, then we can do an automatic compile-time import of it.<!--]--></p><div><!--[--><!--[--><pre><code><span><span>&lt;</span><span>script</span><span>&gt;</span></span><span><span>export</span><span> </span><span>default</span><span> {</span></span><span><span>  </span><span>data</span><span>() {</span></span><span><span>    </span><span>return</span><span> {</span></span><span><span>      bar</span><span>:</span><span> </span><span>'</span><span>foo</span><span>'</span></span><span><span>    }</span></span><span><span>  }</span></span><span><span>}</span></span><span><span>&lt;/</span><span>script</span><span>&gt;</span></span><span></span><span><span>&lt;</span><span>template</span><span>&gt;</span></span><span><span>  &lt;</span><span>div</span><span>&gt;</span></span><span><span>    &lt;</span><span>input</span><span> </span><span>v-my-directive</span><span>=</span><span>\"</span><span>bar</span><span>\"</span><span>&gt;</span></span><span><span>  &lt;/</span><span>div</span><span>&gt;</span></span><span><span>&lt;/</span><span>template</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><p><!--[-->We could imagine that we could write some code which would inject the directive such as <code><!--[-->import MyDirective from \"@/directives/MyDirective\"<!--]--></code>.<!--]--></p><h3><a><!--[-->Progressive Images<!--]--></a></h3><p><!--[-->We hook into the compiling again and replace the source of our images with compile-time low-resolution versions.<!--]--></p><p><!--[--><strong><!--[-->Input<!--]--></strong><!--]--></p><div><!--[--><!--[--><pre><code><span><span>&lt;</span><span>template</span><span>&gt;</span></span><span><span>  &lt;</span><span>v-img</span><span> </span><span>src</span><span>=</span><span>\"</span><span>@/images/my-image</span><span>\"</span><span> /&gt;</span></span><span><span>&lt;/</span><span>template</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><p><!--[--><strong><!--[-->Output<!--]--></strong><!--]--></p><div><!--[--><!--[--><pre><code><span><span>&lt;</span><span>template</span><span>&gt;</span></span><span><span>  &lt;</span><span>v-img</span><span> </span><span>placeholder</span><span>=</span><span>\"</span><span>@/images/my-image-placeholder</span><span>\"</span><span> </span><span>src</span><span>=</span><span>\"</span><span>@/images/my-image</span><span>\"</span><span> /&gt;</span></span><span><span>&lt;/</span><span>template</span><span>&gt;</span></span></code></pre><!--]--><!--]--></div><h3><a><!--[-->Async imports<!--]--></a></h3><p><!--[-->The <code><!--[-->@nuxt/components<!--]--></code> package does offer this functionality as opt-in through a <code><!--[-->Lazy<!--]--></code> prefix on the component.<!--]--></p><p><!--[-->It makes use webpack's <a><!--[-->Lazy Loading<!--]--></a> which bundles imports as their own dependency.\nThis is useful for if you have heavy components that aren't above the fold.<!--]--></p><h2><a><!--[-->Conclusion<!--]--></a></h2><p><!--[-->Vue is already one of the most developer-friendly frontend frameworks around, with continued improvements in the dev experience\nVue will continue to flourish.<!--]--></p><p><!--[-->While these compile-time upgrades are not needed, they do make life easier. The possibilities\nwith injecting code at compile time opens up many opportunities for reducing the 'chores' that seem to follow us around\nproject to project.<!--]--></p><h2><a><!--[-->Thanks for reading<!--]--></a></h2><p><!--[-->webpack and Vue internals are a challenging topic and if you made it all the way through, pat yourself on the back.<!--]--></p><p><!--[-->If you like the technical side of Vue and Laravel, I'll be posting regular articles on this site. The best\nway to keep up to date is by following me <a><!--[-->@harlan_zw<!--]--></a> or signing up for the newsletter below.<!--]--></p></div><!--]-->",
            "url": "nuxt-blog-azure.vercel.app/blog/vue-automatic-component-imports",
            "title": "Building a Vue Auto Component Importer - A Better Dev Experience",
            "summary": "Components magically being imported into your app is the latest developer experience trend in Vue. Why does it exist and how does it work?",
            "image": "https://harlanzw.com/social/vue-automatic-component-imports.png",
            "date_modified": "2020-12-22T00:00:00.000Z",
            "author": {
                "name": "AnyBlog"
            }
        }
    ]
}