import { DeepPartial } from 'utility-types';

declare function defineSchemaOrgResolver<T extends Thing>(schema: SchemaOrgNodeDefinition<T>): SchemaOrgNodeDefinition<T>;

interface SchemaOrgContext {
    readonly nodes: RegisteredThing[];
    meta: ResolvedMeta;
    addNode: <T extends Arrayable<Thing>>(node: T) => void;
    findNode: <T extends Thing>(id: Id | string) => T | null;
    _ctxUid: number;
}
declare const createSchemaOrgGraph: () => SchemaOrgContext;
declare type SchemaOrgGraph = ReturnType<typeof createSchemaOrgGraph>;

declare const renderNodesToSchemaOrgJson: (nodes: RegisteredThing[]) => {
    '@context': string;
    '@graph': RegisteredThing[];
};
declare const renderNodesToSchemaOrgHtml: (nodes: RegisteredThing[], options?: {
    spaces: number;
}) => string;
/**
 * Dedupe, flatten and a collection of nodes. Will also sort node keys and remove meta keys.
 * @param nodes
 */
declare const organiseNodes: (nodes: RegisteredThing[]) => RegisteredThing[];
declare const resolveMeta: (meta: MetaInput) => ResolvedMeta;
declare const buildResolvedGraphCtx: (nodes: Thing[], meta: MetaInput) => SchemaOrgContext;
declare const renderCtxToSchemaOrgJson: (ctx: SchemaOrgContext, meta: MetaInput) => {
    '@context': string;
    '@graph': RegisteredThing[];
};

interface ResolverOptions {
    /**
     * Return single images as an object.
     */
    array?: boolean;
    /**
     * Move added nodes to the root graph.
     */
    root?: boolean;
    /**
     * Generates ids for nodes.
     */
    generateId?: boolean;
    afterResolve?: (node: any) => void;
}
declare const provideResolver: <T>(input?: T | undefined, resolver?: SchemaOrgNodeDefinition<T> | undefined) => WithResolver<T>;

declare const executeResolverOnNode: <T extends Thing>(node: T, ctx: SchemaOrgContext, resolver: SchemaOrgNodeDefinition<T>) => T;
declare const resolveNodeId: <T extends Thing>(node: T, ctx: SchemaOrgContext, resolver: SchemaOrgNodeDefinition<T>, resolveAsRoot?: boolean) => T;
declare function resolveRelation(input: Arrayable<any>, ctx: SchemaOrgContext, fallbackResolver?: SchemaOrgNodeDefinition<any>, options?: ResolverOptions): any;

interface ImageSimple extends Thing {
    /**
     * The URL of the image file (e.g., /images/cat.jpg).
     */
    url: string;
    /**
     * The fully-qualified, absolute URL of the image file (e.g., https://www.example.com/images/cat.jpg).
     * Note: The contentUrl and url properties are intentionally duplicated.
     */
    contentUrl?: string;
    /**
     * A text string describing the image.
     * - Fall back to the image alt attribute if no specific caption field exists or is defined.
     */
    caption?: string;
    /**
     * The height of the image in pixels.
     * - Must be used with width.
     */
    height?: number;
    /**
     * The width of the image in pixels.
     * - Must be used with height.
     */
    width?: number;
    /**
     * The language code for the textual content; e.g., en-GB.
     * - Only needed when providing a caption.
     */
    inLanguage?: string;
}
interface ImageObject extends ImageSimple {
}
/**
 * Describes an individual image (usually in the context of an embedded media object).
 */
declare const imageResolver: SchemaOrgNodeDefinition<ImageObject>;

interface PostalAddressSimple extends Thing {
    /**
     * The building number and street (e.g., 123 fake road ).
     */
    streetAddress: string;
    /**
     * The postal code.
     */
    postalCode: string;
    /**
     * The two-digit country-code representing the country (e.g., US ).
     */
    addressCountry: string;
    /**
     * The town, city or equivalent.
     */
    addressLocality?: string;
    /**
     * The region or district.
     */
    addressRegion?: string;
    /**
     * A PO box number.
     */
    postOfficeBoxNumber?: string;
}
interface PostalAddress extends PostalAddressSimple {
}
declare const addressResolver: SchemaOrgNodeDefinition<PostalAddress>;

/**
 * An organization such as a school, NGO, corporation, club, etc.
 */
interface OrganizationSimple extends Thing {
    /**
     * A reference-by-ID to an image of the organization's logo.
     *
     * - The image must be 112x112px, at a minimum.
     * - Make sure the image looks how you intend it to look on a purely white background
     * (for example, if the logo is mostly white or gray,
     * it may not look how you want it to look when displayed on a white background).
     */
    logo?: NodeRelation<ImageObject | string>;
    /**
     * The site's home URL.
     */
    url?: string;
    /**
     * The name of the Organization.
     */
    name: string;
    /**
     * An array of URLs representing declared social/authoritative profiles of the organization
     * (e.g., a Wikipedia page, or Facebook profile).
     */
    sameAs?: Arrayable<string>;
    /**
     * An array of images which represent the organization (including the logo ), referenced by ID.
     */
    image?: NodeRelations<ImageObject | string>;
    /**
     * A reference-by-ID to an PostalAddress piece.
     */
    address?: NodeRelations<PostalAddress>;
}
interface Organization extends OrganizationSimple {
}
/**
 * Describes an organization (a company, business or institution).
 * Most commonly used to identify the publisher of a WebSite.
 *
 * May be transformed into a more specific type
 * (such as Corporation or LocalBusiness) if the required conditions are met.
 */
declare const organizationResolver: SchemaOrgNodeDefinition<Organization>;

/**
 * A person (alive, dead, undead, or fictional).
 */
interface PersonSimple extends Thing {
    /**
     * The full name of the Person.
     */
    name: string;
    /**
     * The user bio, truncated to 250 characters.
     */
    description?: string;
    /**
     * An array of URLs representing declared social/authoritative profiles of the person
     * (e.g., a Wikipedia page, or Facebook profile).
     */
    sameAs?: Arrayable<string>;
    /**
     * An array of images which represent the person, referenced by ID.
     */
    image?: NodeRelations<ImageObject | string>;
    /**
     * The URL of the users' profile page (if they're affiliated with the site in question),
     * or to their personal homepage/website.
     */
    url?: string;
}
interface Person extends PersonSimple {
}
/**
 * Describes an individual person. Most commonly used to identify the author of a piece of content (such as an Article or Comment).
 */
declare const personResolver: SchemaOrgNodeDefinition<Person>;

declare type Arrayable<T> = T | Array<T>;
declare type NodeRelation<T> = T | IdReference;
declare type NodeRelations<T> = Arrayable<NodeRelation<T>>;
declare type Identity = Person | Organization;
declare type ResolvableDate = string | Date;
declare type OptionalSchemaOrgPrefix<T extends string> = T | `https://schema.org/${T}`;
interface ResolvedMeta {
    host: string;
    url: string;
    currency?: string;
    inLanguage?: string;
    image?: string;
    title?: string;
    description?: string;
    datePublished?: string;
    dateModified?: string;
}
interface MetaInput {
    host: string;
    url?: string;
    path?: string;
    currency?: string;
    image?: string;
    inLanguage?: string;
    title?: string;
    description?: string;
    datePublished?: string;
    dateModified?: string;
    /**
     * @deprecated use `language`
     */
    defaultLanguage?: string;
    /**
     * @deprecated use `currency`
     */
    defaultCurrency?: string;
    /**
     * @deprecated use `host`
     */
    canonicalHost?: string;
    /**
     * @deprecated use `url` or `path`
     */
    canonicalUrl?: string;
}
interface SchemaOrgNodeDefinition<ResolvedInput> {
    alias?: string;
    cast?: (node: any, ctx: SchemaOrgContext) => ResolvedInput;
    idPrefix?: 'host' | 'url' | ['host' | 'url', string];
    inheritMeta?: (keyof ResolvedMeta | {
        key: keyof ResolvedInput;
        meta: keyof ResolvedMeta;
    })[];
    defaults?: DeepPartial<ResolvedInput> | ((ctx: SchemaOrgContext) => DeepPartial<any>);
    required?: (keyof ResolvedInput)[];
    resolve?: (node: ResolvedInput, ctx: SchemaOrgContext) => ResolvedInput;
    rootNodeResolve?: (node: ResolvedInput, ctx: SchemaOrgContext) => void;
}
interface Thing {
    '@type'?: Arrayable<string>;
    '@id'?: Id;
    /**
     * A reference-by-ID to the WebPage node.
     */
    mainEntityOfPage?: Arrayable<IdReference>;
    /**
     * A reference-by-ID to the WebPage node.
     */
    mainEntity?: Arrayable<IdReference>;
    /**
     * An image object or referenced by ID.
     * - Must be at least 696 pixels wide.
     * - Must be of the following formats+file extensions: .jpg, .png, .gif ,or .webp.
     */
    image?: NodeRelations<ImageObject | string>;
    /**
     * Allow any arbitrary keys
     */
    [key: string]: any;
}
interface RegisteredThing extends Thing {
    _resolver?: any;
    _uid: number;
}
declare type WithResolver<T> = T & {
    _resolver?: any;
    _uid?: number;
};
interface IdReference {
    /** IRI identifying the canonical address of this object. */
    '@id': string;
}
declare type Id = `#${string}` | `https://${string}#${string}`;

declare type ItemAvailability = 'BackOrder' | 'Discontinued' | 'InStock' | 'InStoreOnly' | 'LimitedAvailability' | 'OnlineOnly' | 'OutOfStock' | 'PreOrder' | 'PreSale' | 'SoldOut';
interface OfferSimple extends Thing {
    '@type'?: 'Offer';
    /**
     * A schema.org URL representing a schema itemAvailability value (e.g., https://schema.org/OutOfStock).
     */
    availability?: OptionalSchemaOrgPrefix<ItemAvailability>;
    /**
     * The price, omitting any currency symbols, and using '.' to indicate a decimal place.
     */
    price: number | string;
    /**
     * The currency used to describe the product price, in three-letter ISO 4217 format.
     */
    priceCurrency?: string;
    /**
     * @todo A PriceSpecification object, including a valueAddedTaxIncluded property (of either true or false).
     */
    priceSpecification?: unknown;
    /**
     * The date after which the price is no longer available.
     */
    priceValidUntil?: ResolvableDate;
    url?: string;
}
interface Offer extends OfferSimple {
}
declare const offerResolver: SchemaOrgNodeDefinition<Offer>;

interface AggregateOfferSimple extends Thing {
    /**
     * The lowest price of the group, omitting any currency symbols, and using '.' to indicate a decimal place.
     */
    lowPrice: number | string;
    /**
     *  The highest price of the group, omitting any currency symbols, and using '.' to indicate a decimal place.
     */
    highPrice: number | string;
    /**
     * The currency used to describe the product price, in a three-letter ISO 4217 format.
     */
    priceCurrency?: string;
    /**
     * The number of offers in the group
     */
    offerCount?: number | string;
    /**
     * An array of Offer pieces, referenced by ID.
     */
    offers?: NodeRelations<Offer>;
}
interface AggregateOffer extends AggregateOfferSimple {
}
declare const aggregateOfferResolver: SchemaOrgNodeDefinition<AggregateOffer>;

interface AggregateRatingSimple extends Thing {
    '@type'?: 'AggregateRating';
    /**
     * The total number of ratings for the item on your site. At least one of ratingCount or reviewCount is required.
     */
    ratingCount?: number | string;
    /**
     * Specifies the number of people who provided a review with or without an accompanying rating. At least one of ratingCount or reviewCount is required.
     */
    reviewCount?: number | string;
    /**
     * A numerical quality rating for the item, either a number, fraction, or percentage
     * (for example, "4", "60%", or "6 / 10").
     * Google understands the scale for fractions and percentages,
     * since the scale is implied in the fraction itself or the percentage.
     * The default scale for numbers is a 5-point scale, where 1 is the lowest value and 5 is the highest value.
     * If another scale is intended, use bestRating and worstRating.
     */
    ratingValue: number | string;
    /**
     * The highest value allowed in this rating system. If bestRating is omitted, 5 is assumed.
     */
    bestRating?: number | string;
    /**
     * The lowest value allowed in this rating system. If worstRating is omitted, 1 is assumed.
     */
    worstRating?: number | string;
}
interface AggregateRating extends AggregateRatingSimple {
}
declare const aggregateRatingResolver: SchemaOrgNodeDefinition<AggregateRating>;

interface VideoSimple extends Thing {
    /**
     * The title of the video.
     */
    name?: string;
    /**
     * A description of the video (falling back to the caption, then to 'No description').
     */
    description?: string;
    /**
     * A reference-by-ID to an imageObject.
     */
    thumbnailUrl?: NodeRelation<ImageObject>;
    /**
     * The date the video was published, in ISO 8601 format (e.g., 2020-01-20).
     */
    uploadDate?: ResolvableDate;
    /**
     * Whether the video should be considered 'family friendly'
     */
    isFamilyFriendly?: boolean;
    /**
     * The URL of the image file (e.g., /images/cat.jpg).
     */
    url: string;
    /**
     * The fully-qualified, absolute URL of the image file (e.g., https://www.example.com/images/cat.jpg).
     * Note: The contentUrl and url properties are intentionally duplicated.
     */
    contentUrl?: string;
    /**
     * A text string describing the image.
     * - Fall back to the image alt attribute if no specific caption field exists or is defined.
     */
    caption?: string;
    /**
     * The height of the image in pixels.
     * - Must be used with width.
     */
    height?: number;
    /**
     * The width of the image in pixels.
     * - Must be used with height.
     */
    width?: number;
    /**
     * The language code for the textual content; e.g., en-GB.
     * - Only needed when providing a caption.
     */
    inLanguage?: string;
    /**
     * The duration of the video in ISO 8601 format.
     */
    duration?: string;
    /**
     * A URL pointing to a player for the video.
     */
    embedUrl?: string;
}
interface VideoObject extends VideoSimple {
}
/**
 * Describes an individual video (usually in the context of an embedded media object).
 */
declare const videoResolver: SchemaOrgNodeDefinition<VideoObject>;

declare type ValidArticleSubTypes = 'Article' | 'AdvertiserContentArticle' | 'NewsArticle' | 'Report' | 'SatiricalArticle' | 'ScholarlyArticle' | 'SocialMediaPosting' | 'TechArticle';
interface ArticleSimple extends Thing {
    ['@type']?: Arrayable<ValidArticleSubTypes>;
    /**
     * The headline of the article (falling back to the title of the WebPage).
     * Headlines should not exceed 110 characters.
     */
    headline?: string;
    /**
     * A summary of the article (falling back to the page's meta description content).
     */
    description?: string;
    /**
     * A reference-by-ID to the WebPage node.
     */
    isPartOf?: IdReference;
    /**
     * The time at which the article was originally published, in ISO 8601 format; e.g., 2015-10-31T16:10:29+00:00.
     */
    datePublished?: ResolvableDate;
    /**
     * The time at which the article was last modified, in ISO 8601 format; e.g., 2015-10-31T16:10:29+00:00.
     */
    dateModified?: ResolvableDate;
    /**
     * A reference-by-ID to the author of the article.
     */
    author?: NodeRelations<Identity>;
    /**
     * A reference-by-ID to the publisher of the article.
     */
    publisher?: NodeRelations<Identity>;
    /**
     * An array of all videos in the article content, referenced by ID.
     */
    video?: NodeRelations<VideoObject>;
    /**
     * An image object or referenced by ID.
     * - Must be at least 696 pixels wide.
     * - Must be of the following formats+file extensions: .jpg, .png, .gif ,or .webp.
     *
     * Must have markup of it somewhere on the page.
     */
    image?: NodeRelations<ImageObject | string>;
    /**
     * An array of references by ID to comment pieces.
     */
    comment?: NodeRelations<Comment>;
    /**
     * A thumbnail image relevant to the Article.
     */
    thumbnailUrl?: string;
    /**
     * An integer value of the number of comments associated with the article.
     */
    commentCount?: number;
    /**
     * An integer value of the number of words in the article.
     */
    wordCount?: number;
    /**
     * An array of keywords which the article has (e.g., ["cats","dogs","cake"]).
     */
    keywords?: string[];
    /**
     * An array of category names which the article belongs to (e.g., ["cats","dogs","cake"]).
     */
    articleSection?: string[];
    /**
     * The language code for the article; e.g., en-GB.
     */
    inLanguage?: string;
    /**
     * A SpeakableSpecification object which identifies any content elements suitable for spoken results.
     */
    speakable?: unknown;
    /**
     * The year from which the article holds copyright status.
     */
    copyrightYear?: string;
    /**
     * A reference-by-ID to the Organization or Person who holds the copyright.
     */
    copyrightHolder?: NodeRelations<Identity>;
}
interface Article extends ArticleSimple {
}
declare const PrimaryArticleId = "#article";
/**
 * Describes an Article on a WebPage.
 */
declare const articleResolver: SchemaOrgNodeDefinition<Article>;

declare type SearchTarget = string | `${string}{search_term_string}${string | undefined}`;
interface SearchActionInput {
    /**
     * An object of type EntryPoint, with a relative URL which describes the URL pattern of the internal search function
     * (e.g., /search?query={search_term_string}).
     */
    target: SearchTarget;
    /**
     * Alias: The search term string as described in the target (e.g., search_term_string).
     * @default search_term_string
     */
    queryInput?: string;
}
interface SearchAction {
    '@type'?: 'SearchAction';
    /**
     * An object of type EntryPoint, with a relative URL which describes the URL pattern of the internal search function
     * (e.g., /search?query={search_term_string}).
     */
    target: SearchTarget | {
        '@type'?: 'EntryPoint';
        'urlTemplate': SearchTarget;
    };
    /**
     * The search term string as described in the target (e.g., search_term_string).
     */
    'query-input'?: {
        '@type'?: 'PropertyValueSpecification';
        'valueRequired': boolean;
        'valueName': 'search_term_string';
    };
}
declare const searchActionResolver: SchemaOrgNodeDefinition<SearchAction>;

/**
 * A WebSite is a set of related web pages and other items typically served from a single web domain and accessible via URLs.
 */
interface WebSiteSimple extends Thing {
    /**
     * The site's home URL (excluding a trailing slash).
     */
    url?: string;
    /**
     * The name of the website.
     */
    name: string;
    /**
     * A description of the website (e.g., the site's tagline).
     */
    description?: string;
    /**
     * A reference-by-ID to the Organization which publishes the WebSite
     * (or an array of Organization and Person in the case that the website represents an individual).
     */
    publisher?: NodeRelations<Identity>;
    /**
     * A SearchAction object describing the site's internal search.
     */
    potentialAction?: Arrayable<(SearchAction | unknown)>;
    /**
     * The language code for the WebSite; e.g., en-GB.
     * If the website is available in multiple languages, then output an array of inLanguage values.
     */
    inLanguage?: Arrayable<string>;
}
interface WebSite extends WebSiteSimple {
}
declare const PrimaryWebSiteId = "#website";
declare const webSiteResolver: SchemaOrgNodeDefinition<WebSite>;

/**
 * A list item, e.g. a step in a checklist or how-to description.
 */
interface ListItemSimple extends Thing {
    '@type'?: 'ListItem';
    /**
     *  The name of the page in question, as it appears in the breadcrumb navigation.
     */
    name: string;
    /**
     * The unmodified canonical URL of the page in question.
     * - If a relative path is provided, it will be resolved to absolute.
     * - Item is not required for the last entry
     */
    item?: string;
    /**
     *  An integer (starting at 1), counting the 'depth' of the page from (including) the homepage.
     */
    position?: number;
}
interface ListItem extends ListItemSimple {
}
declare const resolveListItem: SchemaOrgNodeDefinition<ListItem>;

interface ItemListSimple extends Thing {
    /**
     * Resolved item list
     */
    itemListElement: NodeRelations<ListItem>;
    /**
     * Type of ordering (e.g. Ascending, Descending, Unordered).
     *
     * @default undefined
     */
    itemListOrder?: 'Ascending' | 'Descending' | 'Unordered';
    /**
     * The number of items in an ItemList.
     * Note that some descriptions might not fully describe all items in a list (e.g., multi-page pagination);
     * in such cases, the numberOfItems would be for the entire list.
     *
     * @default undefined
     */
    numberOfItems?: number;
}
interface ItemList extends ItemListSimple {
}
declare const itemListResolver: SchemaOrgNodeDefinition<ItemList>;

/**
 * A BreadcrumbList is an ItemList consisting of a chain of linked Web pages,
 * typically described using at least their URL and their name, and typically ending with the current page.
 */
interface BreadcrumbSimple extends ItemList {
    '@type'?: 'BreadcrumbList';
}
interface BreadcrumbList extends BreadcrumbSimple {
}
declare const PrimaryBreadcrumbId = "#breadcrumb";
/**
 * Describes the hierarchical position a WebPage within a WebSite.
 */
declare const breadcrumbResolver: SchemaOrgNodeDefinition<BreadcrumbList>;

interface ReadActionInput {
    target?: string[];
}
interface ReadAction {
    '@type'?: 'ReadAction';
    /**
     * An object of type EntryPoint, with a relative URL which describes the URL pattern of the internal search function
     * (e.g., /search?query={search_term_string}).
     */
    target: string[];
}
declare const readActionResolver: SchemaOrgNodeDefinition<ReadAction>;

declare type ValidSubTypes = 'WebPage' | 'AboutPage' | 'CheckoutPage' | 'CollectionPage' | 'ContactPage' | 'FAQPage' | 'ItemPage' | 'MedicalWebPage' | 'ProfilePage' | 'QAPage' | 'RealEstateListing' | 'SearchResultsPage';
/**
 * A web page.
 * Every web page is implicitly assumed to be declared to be of type WebPage,
 * so the various properties about that webpage, such as breadcrumb may be used.
 */
interface WebPageSimple extends Thing {
    ['@type']?: Arrayable<ValidSubTypes>;
    /**
     * The unmodified canonical URL of the page.
     */
    url?: string;
    /**
     * The title of the page.
     */
    name?: string;
    /**
     * The page's meta description content.
     */
    description?: string;
    /**
     * A reference-by-ID to the WebSite node.
     */
    isPartOf?: NodeRelation<WebSite>;
    /**
     * A reference-by-ID to the Organisation node.
     * Note: Only for the home page.
     */
    about?: NodeRelation<Organization>;
    /**
     * A reference-by-ID to the author of the web page.
     */
    author?: NodeRelation<Person | string>;
    /**
     * The language code for the page; e.g., en-GB.
     */
    inLanguage?: Arrayable<string>;
    /**
     * The time at which the page was originally published, in ISO 8601 format; e.g., 2015-10-31T16:10:29+00:00.
     */
    datePublished?: ResolvableDate;
    /**
     * The time at which the page was last modified, in ISO 8601 format; e.g., 2015-10-31T16:10:29+00:00.
     */
    dateModified?: ResolvableDate;
    /**
     * A reference-by-ID to a node representing the page's featured image.
     */
    primaryImageOfPage?: NodeRelation<ImageObject | string>;
    /**
     * A reference-by-ID to a node representing the page's breadrumb structure.
     */
    breadcrumb?: NodeRelation<BreadcrumbList>;
    /**
     * An array of all videos in the page content, referenced by ID.
     */
    video?: NodeRelations<VideoObject>;
    /**
     * A SpeakableSpecification object which identifies any content elements suitable for spoken results.
     */
    speakable?: unknown;
    /**
     * Potential actions for this web page.
     *
     * Note it's on by default for most page types.
     */
    potentialAction?: Arrayable<(ReadAction | unknown)>;
}
interface WebPage extends WebPageSimple {
}
declare const PrimaryWebPageId = "#webpage";
declare const webPageResolver: SchemaOrgNodeDefinition<WebPage>;

interface BookSimple extends Thing {
    /**
     * The title of the book.
     */
    name: string;
    /**
     * A description of the course. Display limit of 60 characters.
     */
    description?: string;
    /**
     *  A reference to an Organization piece, representing brand associated with the Product.
     */
    author?: NodeRelation<Identity>;
    /**
     * The URL on your website where the book is introduced or described.
     */
    url?: string;
    /**
     * The URL of a reference page that identifies the work. For example, a Wikipedia, Wikidata, VIAF, or Library of Congress page for the book.
     */
    sameAs?: Arrayable<string>;
    /**
     * The edition(s) of the work.
     */
    workExample: NodeRelations<BookEdition>;
}
interface Book extends BookSimple {
}
declare type BookFormat = OptionalSchemaOrgPrefix<'AudiobookFormat'> | OptionalSchemaOrgPrefix<'EBook'> | OptionalSchemaOrgPrefix<'Hardcover'> | OptionalSchemaOrgPrefix<'Paperback'>;
interface BookEditionSimple extends Thing {
    /**
     * The title of the edition. Only use this when the title of the edition is different from the title of the work.
     */
    name?: string;
    /**
     * The format of the edition.
     */
    bookFormat: BookFormat;
    /**
     * The main language of the content in the edition. Use one of the two-letter codes from the list of ISO 639-1 alpha-2 codes.
     */
    inLanguage?: string;
    /**
     * The ISBN-13 of the edition. If you have ISBN-10, convert it into ISBN-13.
     */
    isbn: string;
    /**
     * The action to be triggered for users to purchase or download the book.
     */
    potentialAction?: Arrayable<ReadAction | any>;
    /**
     * The author(s) of the edition.
     */
    author?: NodeRelations<Identity>;
    /**
     * The edition information of the book. For example, 2nd Edition.
     */
    bookEdition?: string;
    /**
     * The date of publication of the edition in YYYY-MM-DD or YYYY format. This can be either a specific date or only a specific year.
     */
    datePublished?: ResolvableDate;
    /**
     * The external or other ID that unambiguously identifies this edition. Multiple identifiers are allowed. For more details, refer to PropertyValue (identifier).
     */
    identifier?: unknown;
    /**
     * The URL of a reference web page that unambiguously indicates the edition. For example, a Wikipedia page for this specific edition. Don't reuse the sameAs of the Work.
     */
    sameAs?: Arrayable<string>;
    /**
     * The URL on your website where the edition is introduced or described. It can be the same as workExample.target.urlTemplate.
     */
    url?: string;
}
interface BookEdition extends BookEditionSimple {
}
declare const bookEditionResolver: SchemaOrgNodeDefinition<BookEdition>;
declare const PrimaryBookId = "#book";
declare const bookResolver: SchemaOrgNodeDefinition<Book>;

interface CommentSimple extends Thing {
    /**
     * The textual content of the comment, stripping HTML tags.
     */
    text: string;
    /**
     *  A reference by ID to the parent Article (or WebPage, when no Article is present).
     */
    about?: IdReference;
    /**
     * A reference by ID to the Person who wrote the comment.
     */
    author: NodeRelation<Person>;
}
interface Comment$1 extends CommentSimple {
}
/**
 * Describes a review. Usually in the context of an Article or a WebPage.
 */
declare const commentResolver: SchemaOrgNodeDefinition<Comment$1>;

/**
 * Any offered product or service.
 * For example: a pair of shoes; a concert ticket; the rental of a car;
 * a haircut; or an episode of a TV show streamed online.
 */
interface CourseSimple extends Thing {
    /**
     * The title of the course.
     */
    name: string;
    /**
     * A description of the course. Display limit of 60 characters.
     */
    description?: string;
    /**
     *  A reference to an Organization piece, representing brand associated with the Product.
     */
    provider?: NodeRelation<Organization>;
}
interface Course extends CourseSimple {
}
declare const courseResolver: SchemaOrgNodeDefinition<Course>;

interface PlaceSimple extends Thing {
    '@type'?: 'Place';
    name: string;
    address: NodeRelation<PostalAddress>;
}
interface Place extends PlaceSimple {
}
/**
 * Describes a HowTo guide, which contains a series of steps.
 */
declare const placeResolver: SchemaOrgNodeDefinition<Place>;

interface VirtualLocationSimple extends Thing {
    '@type'?: 'VirtualLocation';
    url: string;
}
interface VirtualLocation extends VirtualLocationSimple {
}
/**
 * Describes a HowTo guide, which contains a series of steps.
 */
declare const virtualLocationResolver: SchemaOrgNodeDefinition<VirtualLocation>;

declare type EventAttendanceModeTypes = 'OfflineEventAttendanceMode' | 'OnlineEventAttendanceMode' | 'MixedEventAttendanceMode';
declare type EventStatusTypes = 'EventCancelled' | 'EventMovedOnline' | 'EventPostponed' | 'EventRescheduled' | 'EventScheduled';
interface EventSimple extends Thing {
    /**
     * Description of the event.
     * Describe all details of the event to make it easier for users to understand and attend the event.
     */
    description?: string;
    /**
     * The end date and time of the item (in ISO 8601 date format).
     */
    endDate?: ResolvableDate;
    /**
     * The eventAttendanceMode of an event indicates whether it occurs online, offline, or a mix.
     */
    eventAttendanceMode?: OptionalSchemaOrgPrefix<EventAttendanceModeTypes>;
    /**
     * An eventStatus of an event represents its status; particularly useful when an event is cancelled or rescheduled.
     */
    eventStatus?: OptionalSchemaOrgPrefix<EventStatusTypes>;
    /**
     * Repeated ImageObject or URL
     *
     * URL of an image or logo for the event or tour.
     * Including an image helps users understand and engage with your event.
     * We recommend that images are 1920px wide (the minimum width is 720px).
     */
    image?: NodeRelations<ImageObject | string>;
    /**
     * The location of the event.
     * There are different requirements depending on if the event is happening online or at a physical location
     */
    location?: NodeRelations<Place | VirtualLocation | string>;
    /**
     * An offer to provide this item—for example, an offer to sell a product,
     * rent the DVD of a movie, perform a service, or give away tickets to an event.
     * Use businessFunction to indicate the kind of transaction offered, i.e. sell, lease, etc.
     * This property can also be used to describe a Demand.
     * While this property is listed as expected on a number of common types, it can be used in others.
     * In that case, using a second type, such as Product or a subtype of Product, can clarify the nature of the offer.
     */
    offers?: NodeRelations<Offer | string>;
    /**
     * An organizer of an Event.
     */
    organizer?: NodeRelation<Identity>;
    /**
     * A performer at the event—for example, a presenter, musician, musical group or actor.
     */
    performer?: NodeRelation<Person>;
    /**
     * Used in conjunction with eventStatus for rescheduled or cancelled events.
     * This property contains the previously scheduled start date.
     * For rescheduled events, the startDate property should be used for the newly scheduled start date.
     * In the (rare) case of an event that has been postponed and rescheduled multiple times, this field may be repeated.
     */
    previousStartDate?: ResolvableDate;
    /**
     * The start date and time of the item (in ISO 8601 date format).
     */
    startDate?: ResolvableDate;
}
interface Event extends EventSimple {
}
declare const PrimaryEventId = "#event";
/**
 * Describes an Article on a WebPage.
 */
declare const eventResolver: SchemaOrgNodeDefinition<Event>;

interface HowToDirection extends Thing {
    /**
     * The text of the direction or tip.
     */
    text: string;
}
/**
 * Describes a HowTo guide, which contains a series of steps.
 */
declare const howToStepDirectionResolver: SchemaOrgNodeDefinition<HowToDirection>;

interface HowToStepSimple extends Thing {
    /**
     * A link to a fragment identifier (an 'ID anchor') of the individual step
     * (e.g., https://www.example.com/example-page/#recipe-step-5).
     */
    url?: string;
    /**
     * The instruction string
     * ("e.g., "Bake at 200*C for 40 minutes, or until golden-brown, stirring periodically throughout").
     */
    text: string;
    /**
     * The word or short phrase summarizing the step (for example, "Attach wires to post" or "Dig").
     * Don't use non-descriptive text (for example, "Step 1: [text]") or other form of step number (for example, "1. [text]").
     */
    name?: string;
    /**
     * An image representing the step, referenced by ID.
     */
    image?: NodeRelations<ImageObject | string>;
    /**
     * A video for this step or a clip of the video.
     */
    video?: NodeRelations<VideoObject | string>;
    /**
     * A list of detailed substeps, including directions or tips.
     */
    itemListElement?: NodeRelations<HowToDirection | string>[];
}
interface HowToStep extends HowToStepSimple {
}
/**
 * Describes a HowTo guide, which contains a series of steps.
 */
declare const howToStepResolver: SchemaOrgNodeDefinition<HowToStep>;

/**
 * Instructions that explain how to achieve a result by performing a sequence of steps.
 */
interface HowToSimple extends Thing {
    /**
     * A string describing the guide.
     */
    name: string;
    /**
     * An array of howToStep objects
     */
    step: NodeRelations<HowToStep | string>[];
    /**
     * The total time required to perform all instructions or directions (including time to prepare the supplies),
     * in ISO 8601 duration format.
     */
    totalTime?: string;
    /**
     * Introduction or description content relating to the HowTo guide.
     */
    description?: string;
    /**
     * The language code for the guide; e.g., en-GB.
     */
    inLanguage?: string;
    /**
     * The estimated cost of the supplies consumed when performing instructions.
     */
    estimatedCost?: string | unknown;
    /**
     * Image of the completed how-to.
     */
    image?: NodeRelations<ImageObject | string>;
    /**
     * A supply consumed when performing instructions or a direction.
     */
    supply?: string | unknown;
    /**
     * An object used (but not consumed) when performing instructions or a direction.
     */
    tool?: string | unknown;
    /**
     * A video of the how-to. Follow the list of required and recommended Video properties.
     * Mark steps of the video with hasPart.
     */
    video?: NodeRelations<VideoObject | string>;
}
interface HowTo extends HowToSimple {
}
declare const HowToId = "#howto";
/**
 * Describes a HowTo guide, which contains a series of steps.
 */
declare const howToResolver: SchemaOrgNodeDefinition<HowTo>;

declare type DayOfWeek = 'Friday' | 'Monday' | 'PublicHolidays' | 'Saturday' | 'Sunday' | 'Thursday' | 'Tuesday' | 'Wednesday';
declare type Time = `${number}${number}:${number}${number}`;
interface OpeningHoursSimple extends Thing {
    '@type'?: 'OpeningHoursSpecification';
    /**
     * The day of the week for which these opening hours are valid.
     */
    dayOfWeek: Arrayable<DayOfWeek>;
    /**
     * The opening hour of the place or service on the given day(s) of the week.
     */
    opens?: Time;
    /**
     * The closing hour of the place or service on the given day(s) of the week.
     */
    closes?: Time;
    /**
     * The date when the item becomes valid.
     */
    validFrom?: ResolvableDate;
    /**
     * The date after when the item is not valid. For example, the end of an offer, salary period, or a period of opening hours.
     */
    validThrough?: ResolvableDate;
}
interface OpeningHoursSpecification extends OpeningHoursSimple {
}
declare const resolveOpeningHours: SchemaOrgNodeDefinition<OpeningHoursSpecification>;

declare type ValidLocalBusinessSubTypes = 'AnimalShelter' | 'ArchiveOrganization' | 'AutomotiveBusiness' | 'ChildCare' | 'Dentist' | 'DryCleaningOrLaundry' | 'EmergencyService' | 'EmploymentAgency' | 'EntertainmentBusiness' | 'FinancialService' | 'FoodEstablishment' | 'GovernmentOffice' | 'HealthAndBeautyBusiness' | 'HomeAndConstructionBusiness' | 'InternetCafe' | 'LegalService' | 'Library' | 'LodgingBusiness' | 'MedicalBusiness' | 'ProfessionalService' | 'RadioStation' | 'RealEstateAgent' | 'RecyclingCenter' | 'SelfStorage' | 'ShoppingCenter' | 'SportsActivityLocation' | 'Store' | 'TelevisionStation' | 'TouristInformationCenter' | 'TravelAgency';
interface LocalBusinessSimple extends Organization {
    '@type'?: ['Organization', 'LocalBusiness'] | ['Organization', 'LocalBusiness', ValidLocalBusinessSubTypes] | ValidLocalBusinessSubTypes;
    /**
     * The primary public telephone number of the business.
     */
    telephone?: string;
    /**
     * The primary public email address of the business.
     */
    email?: string;
    /**
     * The primary public fax number of the business.
     */
    faxNumber?: string;
    /**
     * The price range of the business, represented by a string of dollar symbols (e.g., $, $$, or $$$ ).
     */
    priceRange?: string;
    /**
     * An array of GeoShape, Place or string definitions.
     */
    areaServed?: unknown;
    /**
     * A GeoCoordinates object.
     */
    geo?: unknown;
    /**
     * The VAT ID of the business.
     */
    vatID?: string;
    /**
     * The tax ID of the business.
     */
    taxID?: string;
    /**
     * The currency accepted.
     */
    currenciesAccepted?: string;
    /**
     * The operating hours of the business.
     */
    openingHoursSpecification?: NodeRelations<OpeningHoursSpecification>;
}
interface LocalBusiness extends LocalBusinessSimple {
}
/**
 * Describes a business which allows public visitation.
 * Typically, used to represent the business 'behind' the website, or on a page about a specific business.
 */
declare const localBusinessResolver: SchemaOrgNodeDefinition<LocalBusiness>;

interface RatingSimple extends Thing {
    '@type'?: 'Rating';
    /**
     * A numerical quality rating for the item, either a number, fraction, or percentage
     * (for example, "4", "60%", or "6 / 10").
     * Google understands the scale for fractions and percentages,
     * since the scale is implied in the fraction itself or the percentage.
     * The default scale for numbers is a 5-point scale, where 1 is the lowest value and 5 is the highest value.
     * If another scale is intended, use bestRating and worstRating.
     */
    ratingValue: number | string;
    /**
     * The highest value allowed in this rating system. If bestRating is omitted, 5 is assumed.
     */
    bestRating?: number;
    /**
     * The lowest value allowed in this rating system. If worstRating is omitted, 1 is assumed.
     */
    worstRating?: number;
}
interface Rating extends RatingSimple {
}
declare const ratingResolver: SchemaOrgNodeDefinition<Rating>;

interface ReviewSimple extends Thing {
    /**
     * A title for the review.
     */
    name?: string;
    /**
     * The author of the review.
     */
    author: NodeRelation<Person | string>;
    /**
     * An answer object, with a text property which contains the answer to the question.
     */
    reviewRating: NodeRelation<Rating | number>;
    /**
     * The language code for the question; e.g., en-GB.
     */
    inLanguage?: string;
    /**
     * The date that the review was published, in ISO 8601 date format.
     */
    datePublished?: ResolvableDate;
    /**
     * The text content of the review.
     */
    reviewBody?: string;
}
interface Review extends ReviewSimple {
}
declare const reviewResolver: SchemaOrgNodeDefinition<Review>;

interface MovieSimple extends Thing {
    /**
     * An image that represents the movie.
     */
    image: NodeRelations<string | ImageObject>;
    /**
     * The name of the movie.
     */
    name: string;
    /**
     * Annotation for the average review score assigned to the movie.
     */
    aggregateRating?: NodeRelation<AggregateRating>;
    /**
     * The date the movie was released.
     */
    dateCreated?: ResolvableDate;
    /**
     * The director of the movie.
     */
    director?: NodeRelation<Person | string>;
    /**
     * A nested Review of the movie.
     */
    review?: NodeRelations<Review>;
}
interface Movie extends MovieSimple {
}
declare const movieResolver: SchemaOrgNodeDefinition<Movie>;

/**
 * Any offered product or service.
 * For example: a pair of shoes; a concert ticket; the rental of a car;
 * a haircut; or an episode of a TV show streamed online.
 */
interface ProductSimple extends Thing {
    /**
     * The name of the product.
     */
    name: string;
    /**
     * A reference-by-ID to one or more imageObject's which represent the product.
     * - Must be at least 696 pixels wide.
     * - Must be of the following formats+file extensions: .jpg, .png, .gif ,or .webp.
     */
    image: NodeRelations<ImageObject | string>;
    /**
     *  An array of references-by-ID to one or more Offer or aggregateOffer pieces.
     */
    offers?: NodeRelations<Offer | number>;
    /**
     *  A reference to an Organization piece, representing brand associated with the Product.
     */
    brand?: NodeRelation<Organization>;
    /**
     * A reference to an Organization piece which represents the WebSite.
     */
    seller?: NodeRelation<Organization>;
    /**
     * A text description of the product.
     */
    description?: string;
    /**
     * An array of references-by-id to one or more Review pieces.
     */
    review?: NodeRelations<Review>;
    /**
     * A merchant-specific identifier for the Product.
     */
    sku?: string;
    /**
     * An AggregateRating object.
     */
    aggregateRating?: NodeRelation<AggregateRating>;
    /**
     * An AggregateOffer object.
     */
    aggregateOffer?: NodeRelation<AggregateOffer>;
    /**
     * A reference to an Organization piece, representing the brand which produces the Product.
     */
    manufacturer?: NodeRelation<Organization>;
}
interface Product extends ProductSimple {
}
declare const ProductId = "#product";
declare const productResolver: SchemaOrgNodeDefinition<Product>;

/**
 * An answer offered to a question; perhaps correct, perhaps opinionated or wrong.
 */
interface AnswerSimple extends Thing {
    text: string;
}
interface Answer extends AnswerSimple {
}

/**
 * A specific question - e.g. from a user seeking answers online, or collected in a Frequently Asked Questions (FAQ) document.
 */
interface QuestionSimple extends Thing {
    /**
     * The text content of the question.
     */
    name: string;
    /**
     * An answer object, with a text property which contains the answer to the question.
     */
    acceptedAnswer: NodeRelation<Answer | string>;
    /**
     * The language code for the question; e.g., en-GB.
     */
    inLanguage?: string;
    /**
     * Alias for `name`
     */
    question?: string;
    /**
     * Alias for `acceptedAnswer`
     */
    answer?: string;
}
interface Question extends QuestionSimple {
}
/**
 * Describes a Question. Most commonly used in FAQPage or QAPage content.
 */
declare const questionResolver: SchemaOrgNodeDefinition<Question>;

interface RecipeSimple extends Thing {
    /**
     * A string describing the recipe.
     */
    name?: string;
    /**
     * An image representing the completed recipe, referenced by ID.
     */
    image?: NodeRelation<ImageObject | string>;
    /**
     * An array of strings representing each ingredient and quantity (e.g., "3 apples").
     */
    recipeIngredient: string[];
    /**
     * An array of HowToStep objects.
     */
    recipeInstructions: NodeRelations<HowToStep | string>;
    /**
     * A string describing the recipe.
     */
    description?: string;
    /**
     * The cooking time in ISO 8601 format.
     */
    cookTime?: string;
    /**
     * The time required to prepare the recipe.
     */
    prepTime?: string;
    /**
     * A NutritionInformation node, with a calories property which defines a calorie count as a string (e.g., "270 calories").
     */
    nutrition?: NutritionInformation;
    /**
     * The number of servings the recipe creates (not the number of individual items, if these are different), as a string
     * (e.g., "6", rather than 6).
     */
    recipeYield?: string;
    /**
     * An array of strings representing the tools required in the recipe.
     */
    tools?: string[];
    /**
     * An array of keywords describing the recipe.
     */
    keywords?: string[];
    /**
     * A string describing the cuisine type (e.g., "American" or "Spanish").
     */
    recipeCuisine?: string;
    /**
     * The category of the recipe.
     */
    recipeCategory?: 'Appetizer' | 'Breakfast' | 'Brunch' | 'Dessert' | 'Dinner' | 'Drink' | 'Lunch' | 'Main course' | 'Sauce' | 'Side dish' | 'Snack' | 'Starter';
    /**
     * A RestrictedDiet node, with a value (or array of values
     */
    suitableForDiet?: Partial<'DiabeticDiet' | 'GlutenFreeDiet' | 'HalalDiet' | 'HinduDiet' | 'KosherDiet' | 'LowCalorieDiet' | 'LowFatDiet' | 'LowLactoseDiet' | 'LowSaltDiet' | 'VeganDiet' | 'VegetarianDiet'>[];
    /**
     *  A reference to a video representing the recipe instructions, by ID.
     */
    video?: NodeRelations<VideoObject | IdReference>;
    /**
     * The language code for the guide; e.g., en-GB.
     */
    inLanguage?: string;
    /**
     * A reference-by-ID to the author of the article.
     */
    author?: NodeRelation<Person>;
    /**
     * The date when the recipe was added, in ISO 8601 format.
     */
    datePublished?: ResolvableDate;
}
interface Recipe extends RecipeSimple {
}
interface NutritionInformation extends Thing {
    '@type': 'NutritionInformation';
    /**
     * A calorie count as a string (e.g., "270 calories").
     */
    calories: string;
}
declare const RecipeId = "#recipe";
declare const recipeResolver: SchemaOrgNodeDefinition<Recipe>;

declare type ApplicationCategory = 'GameApplication' | 'SocialNetworkingApplication' | 'TravelApplication' | 'ShoppingApplication' | 'SportsApplication' | 'LifestyleApplication' | 'BusinessApplication' | 'DesignApplication' | 'DeveloperApplication' | 'DriverApplication' | 'EducationalApplication' | 'HealthApplication' | 'FinanceApplication' | 'SecurityApplication' | 'BrowserApplication' | 'CommunicationApplication' | 'DesktopEnhancementApplication' | 'EntertainmentApplication' | 'MultimediaApplication' | 'HomeApplication' | 'UtilitiesApplication' | 'ReferenceApplication';
interface SoftwareAppSimple extends Thing {
    '@type'?: Arrayable<'SoftwareApplication' | 'MobileApplication' | 'VideoGame' | 'WebApplication'>;
    /**
     * The name of the app.
     */
    name?: string;
    /**
     * An offer to sell the app.
     * For developers, offers can indicate the marketplaces that carry the application.
     * For marketplaces, use offers to indicate the price of the app for a specific app instance.
     */
    offers: NodeRelations<Offer>;
    /**
     * The average review score of the app.
     */
    aggregateRating?: NodeRelation<AggregateRating>;
    /**
     * A single review of the app.
     */
    review?: NodeRelation<Review>;
    /**
     * The type of app (for example, BusinessApplication or GameApplication). The value must be a supported app type.
     */
    applicationCategory?: ApplicationCategory;
    /**
     * The operating system(s) required to use the app (for example, Windows 7, OSX 10.6, Android 1.6)
     */
    operatingSystem?: string;
}
interface SoftwareApp extends SoftwareAppSimple {
}
declare const softwareAppResolver: SchemaOrgNodeDefinition<SoftwareApp>;

export { AggregateOffer, AggregateOfferSimple, AggregateRating, AggregateRatingSimple, Arrayable, Article, ArticleSimple, Book, BookEdition, BookEditionSimple, BookSimple, BreadcrumbList, BreadcrumbSimple, Comment$1 as Comment, CommentSimple, Course, CourseSimple, Event, EventSimple, HowTo, HowToDirection, HowToId, HowToSimple, HowToStep, HowToStepSimple, Id, IdReference, Identity, ImageObject, ImageSimple, ItemList, ItemListSimple, ListItem, ListItemSimple, LocalBusiness, LocalBusinessSimple, MetaInput, Movie, MovieSimple, NodeRelation, NodeRelations, NutritionInformation, Offer, OfferSimple, OpeningHoursSimple, OpeningHoursSpecification, OptionalSchemaOrgPrefix, Organization, OrganizationSimple, Person, PersonSimple, Place, PlaceSimple, PostalAddress, PostalAddressSimple, PrimaryArticleId, PrimaryBookId, PrimaryBreadcrumbId, PrimaryEventId, PrimaryWebPageId, PrimaryWebSiteId, Product, ProductId, ProductSimple, Question, QuestionSimple, Rating, RatingSimple, ReadAction, ReadActionInput, Recipe, RecipeId, RecipeSimple, RegisteredThing, ResolvableDate, ResolvedMeta, Review, ReviewSimple, SchemaOrgContext, SchemaOrgGraph, SchemaOrgNodeDefinition, SearchAction, SearchActionInput, SoftwareApp, SoftwareAppSimple, Thing, VideoObject, VideoSimple, VirtualLocation, VirtualLocationSimple, WebPage, WebPageSimple, WebSite, WebSiteSimple, WithResolver, addressResolver, aggregateOfferResolver, aggregateRatingResolver, articleResolver, bookEditionResolver, bookResolver, breadcrumbResolver, buildResolvedGraphCtx, commentResolver, courseResolver, createSchemaOrgGraph, defineSchemaOrgResolver, eventResolver, executeResolverOnNode, howToResolver, howToStepDirectionResolver, howToStepResolver, imageResolver, itemListResolver, localBusinessResolver, movieResolver, offerResolver, organiseNodes, organizationResolver, personResolver, placeResolver, productResolver, provideResolver, questionResolver, ratingResolver, readActionResolver, recipeResolver, renderCtxToSchemaOrgJson, renderNodesToSchemaOrgHtml, renderNodesToSchemaOrgJson, resolveListItem, resolveMeta, resolveNodeId, resolveOpeningHours, resolveRelation, reviewResolver, searchActionResolver, softwareAppResolver, videoResolver, virtualLocationResolver, webPageResolver, webSiteResolver };
