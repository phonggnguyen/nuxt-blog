'use strict';

const node_url = require('node:url');
const unplugin = require('unplugin');
const MagicString = require('magic-string');
const mlly = require('mlly');
const pathe = require('pathe');
const pkgTypes = require('pkg-types');
const pluginutils = require('@rollup/pluginutils');
const meta = require('./schema-org.7f4ed196.cjs');
require('vue');
require('schema-org-graph-js');
const unpluginAst = require('unplugin-ast');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e["default"] : e; }

const MagicString__default = /*#__PURE__*/_interopDefaultLegacy(MagicString);

const AliasRuntimePlugin = unplugin.createUnplugin((userConfig) => {
  userConfig = userConfig || {};
  let cachedPaths;
  let updatedTSConfig = false;
  const fetchPaths = async (ctx, force = false) => {
    if (cachedPaths && !force)
      return cachedPaths;
    let base = (typeof document === 'undefined' ? new (require('u' + 'rl').URL)('file:' + __filename).href : (document.currentScript && document.currentScript.src || new URL('shared/schema-org.a1868659.cjs', document.baseURI).href)).toString();
    if (base.startsWith("file://"))
      base = pathe.dirname(node_url.fileURLToPath(base));
    const pkg = pathe.resolve(base, "../");
    let runtime;
    if (userConfig?.mock) {
      runtime = await mlly.resolvePath(`${pkg}/runtime-mock`);
    } else {
      runtime = await mlly.resolvePath(`${pkg}/runtime-${userConfig?.full ? "schema-dts" : "simple"}`);
      if (!updatedTSConfig && userConfig.dts && ctx.root && process.env.NODE_ENV !== "production") {
        let tsConfigFile = false;
        try {
          tsConfigFile = await pkgTypes.resolveTSConfig(ctx.root);
        } catch {
        }
        if (tsConfigFile) {
          const tsconfig = await pkgTypes.readTSConfig(tsConfigFile);
          tsconfig.compilerOptions = tsconfig.compilerOptions || {};
          tsconfig.compilerOptions.paths = tsconfig.compilerOptions.paths || {};
          const runtimeTsPath = `./${pathe.relative(ctx.root, `${runtime}/index`)}`;
          if (tsconfig.compilerOptions.paths[meta.AliasRuntime]?.[0] !== runtimeTsPath) {
            tsconfig.compilerOptions.paths[meta.AliasRuntime] = [runtimeTsPath];
            updatedTSConfig = true;
          }
          if (updatedTSConfig)
            await pkgTypes.writeTSConfig(tsConfigFile, tsconfig);
          updatedTSConfig = true;
        }
      }
    }
    const resolvedPaths = {
      pkg,
      runtime,
      root: ctx.root || ""
    };
    if (ctx.root)
      cachedPaths = resolvedPaths;
    return resolvedPaths;
  };
  return {
    name: "@vueuse/schema-org:aliases",
    enforce: "pre",
    async buildStart() {
      await fetchPaths({ root: userConfig.root });
    },
    transformInclude(id) {
      if (userConfig.root && id.startsWith(userConfig.root)) {
        const filter = pluginutils.createFilter([
          /\.[jt]sx?$/,
          /\.vue$/
        ], [
          "node_modules"
        ]);
        return filter(id);
      }
      return false;
    },
    transform(code) {
      const s = new MagicString__default(code);
      s.replace(meta.AliasRuntime, cachedPaths.runtime);
      if (s.hasChanged()) {
        return {
          code: s.toString(),
          map: s.generateMap()
        };
      }
    },
    async webpack(compiler) {
      const { runtime } = await fetchPaths({ root: compiler.context });
      compiler.options.resolve.alias = {
        ...compiler.options.resolve.alias || {},
        [meta.AliasRuntime]: runtime
      };
    },
    vite: {
      async config(config, ctx) {
        const root = userConfig.root || config.root || process.cwd();
        let paths;
        const isServerBuild = process.env.VITE_SSG || ctx.ssrBuild;
        const isProduction = config.mode === "production" || ctx.mode === "production";
        if (typeof userConfig.mock === "undefined" && !isServerBuild && isProduction) {
          userConfig.mock = true;
          paths = await fetchPaths({ root }, true);
        } else {
          paths = await fetchPaths({ root });
        }
        const { pkg, runtime } = paths;
        config.optimizeDeps = config.optimizeDeps || {};
        config.optimizeDeps.exclude = config.optimizeDeps.exclude || [];
        config.optimizeDeps.exclude.push(...[runtime, pkg, meta.PkgName]);
        config.resolve = config.resolve || {};
        config.resolve.alias = config.resolve.alias || {};
        config.resolve.alias[meta.AliasRuntime] = runtime;
        return config;
      }
    }
  };
});

const RemoveFunctions = (functionNames) => ({
  onNode: (node) => node.type === "CallExpression" && node.callee.type === "Identifier" && functionNames.includes(node.callee.name),
  transform() {
    return false;
  }
});
const RemoveUseSchemaPlugin = unplugin.createUnplugin((userConfig = {}) => {
  const filter = pluginutils.createFilter([
    /\.[jt]sx?$/,
    /\.vue$/
  ], [
    "node_modules"
  ]);
  let root = userConfig.root;
  return {
    name: "@vueuse/schema-org:remove-use-schema",
    enforce: "post",
    transformInclude(id) {
      if (root && !id.startsWith(root))
        return false;
      return filter(id);
    },
    async transform(code, id) {
      let transformed;
      try {
        transformed = await unpluginAst.transform(code, id, {
          parserOptions: {},
          transformer: [
            RemoveFunctions(["useSchemaOrg"])
          ]
        });
      } catch (e) {
      }
      return transformed;
    },
    vite: {
      async config(config) {
        root = root || config.root || process.cwd();
      }
    }
  };
});

exports.AliasRuntimePlugin = AliasRuntimePlugin;
exports.RemoveUseSchemaPlugin = RemoveUseSchemaPlugin;
