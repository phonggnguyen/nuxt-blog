import { fileURLToPath } from 'node:url';
import { createUnplugin } from 'unplugin';
import MagicString from 'magic-string';
import { resolvePath } from 'mlly';
import { dirname, resolve, relative } from 'pathe';
import { resolveTSConfig, readTSConfig, writeTSConfig } from 'pkg-types';
import { createFilter } from '@rollup/pluginutils';
import { A as AliasRuntime, P as PkgName } from './schema-org.714403e2.mjs';
import 'vue';
import 'schema-org-graph-js';
import { transform } from 'unplugin-ast';

const AliasRuntimePlugin = createUnplugin((userConfig) => {
  userConfig = userConfig || {};
  let cachedPaths;
  let updatedTSConfig = false;
  const fetchPaths = async (ctx, force = false) => {
    if (cachedPaths && !force)
      return cachedPaths;
    let base = import.meta.url.toString();
    if (base.startsWith("file://"))
      base = dirname(fileURLToPath(base));
    const pkg = resolve(base, "../");
    let runtime;
    if (userConfig?.mock) {
      runtime = await resolvePath(`${pkg}/runtime-mock`);
    } else {
      runtime = await resolvePath(`${pkg}/runtime-${userConfig?.full ? "schema-dts" : "simple"}`);
      if (!updatedTSConfig && userConfig.dts && ctx.root && process.env.NODE_ENV !== "production") {
        let tsConfigFile = false;
        try {
          tsConfigFile = await resolveTSConfig(ctx.root);
        } catch {
        }
        if (tsConfigFile) {
          const tsconfig = await readTSConfig(tsConfigFile);
          tsconfig.compilerOptions = tsconfig.compilerOptions || {};
          tsconfig.compilerOptions.paths = tsconfig.compilerOptions.paths || {};
          const runtimeTsPath = `./${relative(ctx.root, `${runtime}/index`)}`;
          if (tsconfig.compilerOptions.paths[AliasRuntime]?.[0] !== runtimeTsPath) {
            tsconfig.compilerOptions.paths[AliasRuntime] = [runtimeTsPath];
            updatedTSConfig = true;
          }
          if (updatedTSConfig)
            await writeTSConfig(tsConfigFile, tsconfig);
          updatedTSConfig = true;
        }
      }
    }
    const resolvedPaths = {
      pkg,
      runtime,
      root: ctx.root || ""
    };
    if (ctx.root)
      cachedPaths = resolvedPaths;
    return resolvedPaths;
  };
  return {
    name: "@vueuse/schema-org:aliases",
    enforce: "pre",
    async buildStart() {
      await fetchPaths({ root: userConfig.root });
    },
    transformInclude(id) {
      if (userConfig.root && id.startsWith(userConfig.root)) {
        const filter = createFilter([
          /\.[jt]sx?$/,
          /\.vue$/
        ], [
          "node_modules"
        ]);
        return filter(id);
      }
      return false;
    },
    transform(code) {
      const s = new MagicString(code);
      s.replace(AliasRuntime, cachedPaths.runtime);
      if (s.hasChanged()) {
        return {
          code: s.toString(),
          map: s.generateMap()
        };
      }
    },
    async webpack(compiler) {
      const { runtime } = await fetchPaths({ root: compiler.context });
      compiler.options.resolve.alias = {
        ...compiler.options.resolve.alias || {},
        [AliasRuntime]: runtime
      };
    },
    vite: {
      async config(config, ctx) {
        const root = userConfig.root || config.root || process.cwd();
        let paths;
        const isServerBuild = process.env.VITE_SSG || ctx.ssrBuild;
        const isProduction = config.mode === "production" || ctx.mode === "production";
        if (typeof userConfig.mock === "undefined" && !isServerBuild && isProduction) {
          userConfig.mock = true;
          paths = await fetchPaths({ root }, true);
        } else {
          paths = await fetchPaths({ root });
        }
        const { pkg, runtime } = paths;
        config.optimizeDeps = config.optimizeDeps || {};
        config.optimizeDeps.exclude = config.optimizeDeps.exclude || [];
        config.optimizeDeps.exclude.push(...[runtime, pkg, PkgName]);
        config.resolve = config.resolve || {};
        config.resolve.alias = config.resolve.alias || {};
        config.resolve.alias[AliasRuntime] = runtime;
        return config;
      }
    }
  };
});

const RemoveFunctions = (functionNames) => ({
  onNode: (node) => node.type === "CallExpression" && node.callee.type === "Identifier" && functionNames.includes(node.callee.name),
  transform() {
    return false;
  }
});
const RemoveUseSchemaPlugin = createUnplugin((userConfig = {}) => {
  const filter = createFilter([
    /\.[jt]sx?$/,
    /\.vue$/
  ], [
    "node_modules"
  ]);
  let root = userConfig.root;
  return {
    name: "@vueuse/schema-org:remove-use-schema",
    enforce: "post",
    transformInclude(id) {
      if (root && !id.startsWith(root))
        return false;
      return filter(id);
    },
    async transform(code, id) {
      let transformed;
      try {
        transformed = await transform(code, id, {
          parserOptions: {},
          transformer: [
            RemoveFunctions(["useSchemaOrg"])
          ]
        });
      } catch (e) {
      }
      return transformed;
    },
    vite: {
      async config(config) {
        root = root || config.root || process.cwd();
      }
    }
  };
});

export { AliasRuntimePlugin as A, RemoveUseSchemaPlugin as R };
