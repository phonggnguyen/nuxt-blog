import { createHead, renderHeadToString } from "@vueuse/head";
import { defineNuxtPlugin, useRoute, useRouter } from "#app";
import { defu } from "defu";
import { packMeta } from "zhead";
import { computed, getCurrentInstance, onBeforeUnmount, ref, watch, watchEffect } from "vue";
import options from "#build/nuxt-hedge-config.mjs";
export default defineNuxtPlugin((nuxtApp) => {
  const { resolveAliases, seoOptimise } = options;
  const head = createHead();
  nuxtApp.vueApp.use(head);
  let headReady = false;
  nuxtApp.hooks.hookOnce("app:mounted", () => {
    watchEffect(() => {
      head.updateDOM();
    });
    headReady = true;
  });
  if (resolveAliases) {
    head.hookTagsResolved.push(async (tags) => {
      const props = ["href", "src"];
      for (const i in tags) {
        for (const prop of props) {
          if (tags[i]?.props?.[prop] && /^[~@]+\//.test(tags[i].props[prop])) {
            if (process.server) {
              tags[i].props[prop] = await import(
                /* @vite-ignore */
                `${tags[i].props[prop]}?url`
              );
            } else {
              tags.splice(i, 1);
            }
          }
        }
      }
    });
  }
  if (seoOptimise) {
    head.hookTagsResolved.push((tags) => {
      const metaProps = [];
      let title = "";
      for (const i in tags) {
        if (tags[i].tag === "meta")
          metaProps.push(tags[i].props);
        if (tags[i].tag === "title")
          title = tags[i].props.children;
      }
      const meta = packMeta(metaProps);
      if (meta.ogImage && !meta.twitterCard) {
        tags.push({
          tag: "meta",
          props: {
            name: "twitter:card",
            content: "summary_large_image"
          }
        });
      }
      if (title && !meta.ogTitle) {
        tags.push({
          tag: "meta",
          props: {
            name: "og:title",
            content: title
          }
        });
      }
      if (meta.description && !meta.ogDescription) {
        tags.push({
          tag: "meta",
          props: {
            name: "og:description",
            content: meta.description
          }
        });
      }
    });
  }
  let pauseDOMUpdates = false;
  head.hookBeforeDomUpdate.push(() => !pauseDOMUpdates);
  nuxtApp.hooks.hookOnce("page:finish", () => {
    pauseDOMUpdates = false;
    useRouter().beforeEach(() => {
      pauseDOMUpdates = true;
    });
    watch(useRoute(), () => {
      pauseDOMUpdates = false;
      head.updateDOM();
    });
  });
  nuxtApp._useHead = (_meta) => {
    const meta = ref(_meta);
    const headObj = computed(() => {
      const overrides = { meta: [] };
      if (meta.value.charset) {
        overrides.meta.push({
          key: "charset",
          charset: meta.value.charset
        });
      }
      if (meta.value.viewport) {
        overrides.meta.push({
          name: "viewport",
          content: meta.value.viewport
        });
      }
      return defu(overrides, meta.value);
    });
    head.addHeadObjs(headObj);
    if (process.server)
      return;
    if (headReady)
      watchEffect(() => {
        head.updateDOM();
      });
    const vm = getCurrentInstance();
    if (!vm)
      return;
    onBeforeUnmount(() => {
      head.removeHeadObjs(headObj);
      head.updateDOM();
    });
  };
  if (process.server) {
    nuxtApp.ssrContext.renderMeta = () => {
      const meta = renderHeadToString(head);
      return {
        ...meta,
        bodyScripts: meta.bodyTags
      };
    };
  }
});
