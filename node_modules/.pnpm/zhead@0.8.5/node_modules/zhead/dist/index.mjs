import { packArray, unpackToArray, unpackToString } from 'packrup';
import { headSchema } from '@zhead/zod';

function defineHead(input) {
  return input;
}
function defineHeadRaw(input) {
  return input;
}

const PropertyPrefixKeys = /^(og|twitter|fb)/;
function fixKeyCase(key) {
  key = key.replace(/([A-Z])/g, "-$1").toLowerCase();
  if (PropertyPrefixKeys.test(key)) {
    key = key.replace("secure-url", "secure_url").replace(/-/g, ":");
  }
  return key;
}
function changeKeyCasingDeep(input) {
  if (Array.isArray(input)) {
    return input.map((entry) => changeKeyCasingDeep(entry));
  }
  if (typeof input !== "object" || Array.isArray(input))
    return input;
  const output = {};
  for (const [key, value] of Object.entries(input))
    output[fixKeyCase(key)] = changeKeyCasingDeep(value);
  return output;
}

const MetaPackingSchema = {
  robots: {
    unpack: {
      keyValueSeparator: ":"
    }
  },
  contentSecurityPolicy: {
    unpack: {
      keyValueSeparator: " ",
      entrySeparator: "; "
    },
    metaKey: "http-equiv"
  },
  fbAppId: {
    keyValue: "fb:app_id",
    metaKey: "property"
  },
  msapplicationTileImage: {
    keyValue: "msapplication-TileImage"
  },
  msapplicationTileColor: {
    keyValue: "msapplication-TileColor"
  },
  msapplicationConfig: {
    keyValue: "msapplication-Config"
  },
  charset: {
    metaKey: "charset"
  },
  contentType: {
    metaKey: "http-equiv"
  },
  defaultStyle: {
    metaKey: "http-equiv"
  },
  xUaCompatible: {
    metaKey: "http-equiv"
  },
  refresh: {
    metaKey: "http-equiv"
  }
};
function resolveMetaKeyType(key) {
  return PropertyPrefixKeys.test(key) ? "property" : MetaPackingSchema[key]?.metaKey || "name";
}

function packMeta(inputs) {
  const mappedPackingSchema = Object.entries(MetaPackingSchema).map(([key, value]) => [key, value.keyValue]);
  return packArray(inputs, {
    key: ["name", "property", "httpEquiv", "http-equiv", "charset"],
    value: ["content", "charset"],
    resolveKey(k) {
      let key = mappedPackingSchema.filter((sk) => sk[1] === k)?.[0]?.[0] || k;
      const replacer = (_, letter) => letter?.toUpperCase();
      key = key.replace(/:([a-z])/g, replacer).replace(/-([a-z])/g, replacer);
      return key;
    }
  });
}

function unpackMeta(input) {
  return unpackToArray(input, {
    key({ key }) {
      return resolveMetaKeyType(key);
    },
    value({ key }) {
      return key === "charset" ? "charset" : "content";
    },
    resolveKeyData({ key }) {
      return MetaPackingSchema[key]?.keyValue || fixKeyCase(key);
    },
    resolveValueData({ value, key }) {
      if (typeof value === "object") {
        const definition = MetaPackingSchema[key];
        if (key === "refresh")
          return `${value.seconds};url=${value.url}`;
        return unpackToString(
          changeKeyCasingDeep(value),
          {
            entrySeparator: ", ",
            keyValueSeparator: "=",
            resolve({ value: value2, key: key2 }) {
              if (typeof value2 === "boolean")
                return `${key2}`;
            },
            ...definition?.unpack
          }
        );
      }
      return typeof value === "number" ? value.toString() : value;
    }
  });
}

function resolveSeoHead(input) {
  const output = { ...input };
  const metaFlat = withInferredSeoMeta(
    output,
    withDefaultMeta(
      output,
      output.meta ? packMeta(output.meta) : {}
    )
  );
  output.meta = unpackMeta(metaFlat);
  return output;
}
function withDefaultMeta(head, metaFlat) {
  if (!metaFlat.charset)
    metaFlat.charset = "utf-8";
  if (!metaFlat.viewport) {
    metaFlat.viewport = {
      initialScale: 1,
      width: "device-width"
    };
  }
  return metaFlat;
}
function withInferredSeoMeta(head, metaFlat) {
  if (metaFlat.ogImage && !metaFlat.twitterCard)
    metaFlat.twitterCard = "summary_large_image";
  if (head.title && !metaFlat.ogTitle)
    metaFlat.ogTitle = head.title;
  if (metaFlat.description && !metaFlat.ogDescription)
    metaFlat.ogDescription = metaFlat.description;
  if (!metaFlat.robots) {
    metaFlat.robots = {
      maxSnippet: -1,
      maxImagePreview: "large",
      maxVideoPreview: -1
    };
  }
  return metaFlat;
}

function generateTagsStrict(input) {
  const parsed = headSchema.parse(input);
  return generateTags(parsed);
}
function primitiveToTag(tag, v) {
  if (typeof v === "object") {
    if (Object.keys(v).length > 0)
      return { tag, props: changeKeyCasingDeep(v) };
  } else {
    return { tag, props: { children: v } };
  }
}
function generateTags(input) {
  const output = [];
  for (const tag of Object.keys(input)) {
    const v = Array.isArray(input[tag]) ? input[tag] : [input[tag]];
    output.push(
      v.map((entry) => primitiveToTag(tag, entry)).filter((v2) => !!v2)
    );
  }
  return output.flat();
}

const SelfClosingTags = ["meta", "link", "base"];
const tagToString = (tag) => {
  const { children } = tag.props;
  delete tag.props.children;
  delete tag.props.key;
  let attrs = unpackToString(tag.props, {
    entrySeparator: " ",
    keyValueSeparator: "=",
    wrapValue: '"',
    resolve({ key, value }) {
      if (typeof value === "boolean")
        return key;
    }
  });
  attrs = attrs ? ` ${attrs}` : "";
  if (SelfClosingTags.includes(tag.tag))
    return `<${tag.tag}${attrs}>`;
  return `<${tag.tag}${attrs}>${children || ""}</${tag.tag}>`;
};

function generateHtml(input) {
  return generateTags(input).map((t) => tagToString(t)).join("\n");
}
function generateHtmlStrict(input) {
  return generateTagsStrict(input).map((t) => tagToString(t)).join("\n");
}

const renderTemplate = (template, title) => {
  if (template == null)
    return "";
  if (typeof template === "string")
    return template.replace("%s", title ?? "");
  return template(title);
};

export { defineHead, defineHeadRaw, generateHtml, generateHtmlStrict, generateTags, generateTagsStrict, packMeta, renderTemplate, resolveSeoHead, unpackMeta };
